#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/constants.glsl"

//#ifndef USE_EMULATED
//#extension GL_ARB_bindless_texture : require
//#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
//#include "../include/textureManager.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

/* Water and optics settings */
#define SUNLIGHT_CAUSTICS
#define WATER_REFRACTION_ENABLED
#define WATER_REFRACTION_SKIP_SUN
#define PHI 1.6180339887498948482

/* Atmosphere sky functions and parameters */
#define up vec3(0.0f, 1.0f, 0.0f)
#define atmosphereColor vec3(0.18, 0.49, 0.66)
#define rayleighAmmount .06*0.5
#define mieAmmount .002*0.5
#define atmosphereHeight .4*0.2
#define earthRadius 14.6*0.2
#define getThickness(a) js_getThickness(a)
#define getEarth(a) clamp( dot(up,a)*10.+1. ,0.,1.)
#define phaseRayleigh(a) (.059683104 * (1. + a * a))
#define phaseMie(a) (.0348151 / pow(1.5625 - 1.5*a,1.5))
#define absorb(a) (1. - pow(atmosphereColor, vec3(1./(a))))

LOCAL_SIZE_LAYOUT;

float js_getThickness(in vec3 rd){
    const float sr = earthRadius+atmosphereHeight;
    const vec3 ro = -up*earthRadius;
    const float b = dot(rd, ro);
    const float c = dot(ro, ro) - sr*sr;
    const float t = b*b - c;
    return b + sqrt(t);
}

vec3 saturate(in vec3 c, in float s) {
    return c*s+dot(c, vec3(.2125, .7154, .0721) )*(1 - s);
}

vec3 js_getScatter(in vec3 V, in vec3 L, in float lightStrength) {
    const float thicknessV = getThickness(V), dotVL = dot(V, L);
    const vec3 sunColor = lightStrength * absorb(getThickness(L)) * getEarth(L);
    const vec3 rayleighGradient = atmosphereColor * rayleighAmmount * phaseRayleigh(dotVL);
    const float mieGradient = mieAmmount * phaseMie(dotVL);
    vec3 skyColor = (mieGradient + rayleighGradient) * absorb(thicknessV) * sunColor * thicknessV;
    skyColor += pow(max(dotVL,0.), 7000.) * sunColor; //sun
    return saturate(skyColor,1.3)*vec3(1,1,1.35);
}


float wave(in float n) {
    return sin(2 * PI * (n));
}

float mat(in float pos) {
    return fract(sin(pos)*43758.5453);
}

float Wnoise2D(in vec2 x, in float n){
    const vec2 p = floor(x), f = fract(x);
    const float m = p.x + p.y*n;
    return mix(mix(mat(m-1), mat(m),f.x), mix(mat(m+(n-1)), mat(m+n),f.x),f.y);
}

float waterH(in vec3 posxz, in float frameTimeCounter) {
    float noise = 0.0, freq = 1.0, amp = 1.0, n = 32.0;
    const vec2 coord = -n+n*fract(posxz.xz / 1000.0), tock = vec2(frameTimeCounter / 100.0);
    for( int i = 0; i < 2; i++) {
        noise += Wnoise2D(-n+n*(coord + tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
        noise += Wnoise2D(-n+n*(coord - tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
    }
    return noise * 5.0;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);
    result = mat.diffuse;

    if(validateTexture(mat.diffusePart)) {
        result = fetchPart(mat.diffusePart, texcoord);
    }

    result.xyz = pow(result.xyz, vec3(GAMMA));
    return result;
}

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    if (it >= RAY_BLOCK samplerUniform.rayCount) return;

    const int t = actived[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    Hit hit = fetchHitDirect(t);

    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        storeRay(t, newRay);
        return;
    }

    int lc = -1;
    for (int i=0;i<RAY_BLOCK materialUniform.lightcount;i++) {
        if ( newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 )) {
            float md = 1.0f;
            Ray tempRay = transformRay(newRay, md);
            const float dt = intersectSphere(tempRay.origin.xyz, tempRay.direct.xyz, lightCenter(i).xyz, lightUniform[i].lightColor.w + GAP);
            const float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
                hit.shaded = 1;
            }
        }
    }

    // light achieved?
    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz * getLightColor(lc);
        newRay.actived = 0;
    }



    if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1 && hit.shaded < 1) {
        newRay = transformRay(newRay);

        const vec3 lcenter = lightCenterSky(0);
        vec3 color = //vec3(0.8f, 0.9f, 1.0f);
            js_getScatter(newRay.direct.xyz, -normalize(lcenter - newRay.origin.xyz), 800.0f) +
            js_getScatter(newRay.direct.xyz,  normalize(lcenter - newRay.origin.xyz), 4000.0f);
        color = 1.0f - exp(-1.0f * color);
        color = pow(color, vec3(GAMMA));

        newRay.final.xyz = newRay.color.xyz * color;
        newRay = unTransformRay(newRay);
        newRay.actived = 0;

        hit.triangle = 0;
        hit.dist = INFINITY;
        hit.materialID = LONGEST;
        hit.shaded = 1;
    }



    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        storeHit(t, hit);
        storeRay(t, newRay);
        return;
    }



    const uint l = gl_LocalInvocationID.x;
     Submat materialCache = submats[hit.materialID];
    hit.shaded = 1;

    const vec3 dir = normalize(newRay.direct.xyz);
    const vec3 prenormal = normalize(hit.normal.xyz);

    float inior = 1.0f;
    float outior = materialCache.ior;
    const float inside = dot(prenormal, dir);
    if (inside >= 0.0f) {
        const float tmp = inior;
        inior = outior;
        outior = tmp;
    }

    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    const vec3 surfacenormal = normal;
    const vec3 tan = normalize(hit.tangent.xyz);
    const mat3 tbn = mat3(tan, cross(normal, tan), normal);
    normal = normalize(tbn * getNormalMapping(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);

    const float glossiness = clamp(1.0f / log2(materialCache.reflectivity), 0.0f, 1.0f);
    const bool isWater = iseq16(hit.vmods.x, 8.f) || iseq16(hit.vmods.x, 9.f);
    const bool isGlass = iseq16(hit.vmods.x, 20.f) || iseq16(hit.vmods.x, 102.f);
    const bool isStained = iseq16(hit.vmods.x, 95.f) || iseq16(hit.vmods.x, 160.f);

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    vec4 tts = clamp(fetchTransmission(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 emi = materialCache.emissive;//fetchEmissive(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    vec4 sp = fetchSpecular(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    vec4 rc = vec4(mix(sp.xyz, tx.xyz, glossiness), 1.0f);

    if ( iseq16(hit.vmods.x, 89.f) ) { // glowstone
        emi = vec4(8.0f);
    }

    if ( iseq16(hit.vmods.x, 10.f) || iseq16(hit.vmods.x, 11.f) ) { // lava
        emi = vec4(7.0f);
    }

    if ( iseq16(hit.vmods.x, 76.f) ) { // redstone torch
        emi = vec4(8.0f);
    }

    if ( iseq16(hit.vmods.x, 50.f) ) { // torch
        emi = vec4(12.0f);
    }


    const float trns = clamp(mlength(tts.xyz), 0.0f, 1.0f);
    const float emis = mlength(emi.xyz);
    const float spic = mlength(rc.xyz);
    const float prom = 1.0f - tx.a;
    float fres = computeFresnel(hit.normal.xyz, newRay.direct.xyz, inior, outior) * (inside <= 0.0f ? 1.0f : 0.0f);

    emi *= tx;

    float grefl = 0.2f + pow((1.0f - abs(dot(normal, newRay.direct.xyz))), 2.0f) * 0.6f;
    bool diffused = false;

    if (isGlass) {

        // glass transparency
        float trnsy = prom * (1.0f - grefl);
        if (greaterF(trnsy, 0.0f)) emitRay(promised(newRay, hit, normal), hit, normal, trnsy);

        // glass reflection (on transparency)
        float refly = prom * grefl;
        if (greaterF(refly, 0.0f)) emitRay(reflection(newRay, hit, vec3(1.0f), normal, 0.0f), hit, normal, refly);

        {
            // glass frames (diffuse)
            newRay.color.xyz *= 1.0f - prom;
            newRay = diffuse(newRay, hit, tx.xyz, normal);

#ifdef DIRECT_LIGHT
            if (diffused) applyLight(directLight(0, newRay, hit, vec3(1.0f), normal), newRay, surfacenormal);
#endif

            diffused = true;
        }

    } else

    if (isStained) {

        // glass reflection
        emitRay(reflection(newRay, hit, vec3(1.0f), normal, 0.0f), hit, normal, grefl);
        newRay.color.xyz *= (1.0f - grefl);

        // stained transparency (with multiply)
        newRay = refraction(newRay, hit, mix(tx.xyz, vec3(1.0f), vec3(prom)), normal, 1.0f, 1.0f, 0.0f);

    } else

    if (isWater) {
        const float frameTimeCounter = float(double(RAY_BLOCK materialUniform.iModifiers0.w) / 60000.0f) * 4.0f;
        vec3 posxz = (inverse(RAY_BLOCK materialUniform.transformModifier) * vec4(newRay.origin.xyz, 1.0f)).xyz;
        posxz.x += sin(posxz.z+frameTimeCounter)*0.25;
        posxz.z += cos(posxz.x+frameTimeCounter*0.5)*0.25;

        const float deltaPos = 0.1f;
        const float h0 = waterH(posxz, frameTimeCounter);
        const float h1 = waterH(posxz + vec3(deltaPos,0.0,0.0), frameTimeCounter);
        const float h2 = waterH(posxz + vec3(-deltaPos,0.0,0.0), frameTimeCounter);
        const float h3 = waterH(posxz + vec3(0.0,0.0,deltaPos), frameTimeCounter);
        const float h4 = waterH(posxz + vec3(0.0,0.0,-deltaPos), frameTimeCounter);
        const float xDelta = ((h1-h0)+(h0-h2))/deltaPos;
        const float yDelta = ((h3-h0)+(h0-h4))/deltaPos;

        vec3 bump = normalize(vec3(xDelta,yDelta,1.0-xDelta*xDelta-yDelta*yDelta));
        const float bumpmult = 0.1f;
        bump = bump * vec3(bumpmult, bumpmult, bumpmult) + vec3(0.0f, 0.0f, 1.0f - bumpmult);
        normal = normalize(tbn * bump);

        inior = 1.0f;
        outior = 1.333333333f;
        const float inside = dot(prenormal, dir);
        if (inside >= 0.0f) {
            const float tmp = inior;
            inior = outior;
            outior = tmp;
        }

        Ray promRay = reflection(newRay, hit, vec3(1.0f), normal, 0.0f);
        Ray refrRay = refraction(newRay, hit, vec3( 1.0f ), normal, inior, outior, 0.0f);
        const float fres = computeFresnel(normal, newRay.direct.xyz, inior, outior) * (inside <= 0.0f ? 1.0f : 0.0f);
        if (newRay.params.w == 0) {
            emitRay(promRay, hit, normal, fres);
        }
        newRay = refrRay;
        newRay.color.xyz *= 1.0f - fres;

    } else

    {
        if (materialCache.binding >= 0 && texelInfo[newRay.texel].EXT.x < 0) {
            texelInfo[newRay.texel].EXT.x = materialCache.binding;
        }

        const bool additiveBlend = false;
        const float amod = additiveBlend ? 1.0f : prom;

        Ray emitentRay = newRay;
        if (random() < emis) {
            emitentRay = emissive(newRay, hit, emi.xyz / min(emis, 1.0f), normal);
        } else
        if (random() < spic) {
            emitentRay = reflection(newRay, hit, rc.xyz, normal, glossiness);
        } else
        //if (random() < trns){ // Todo for basic renders
        //    emitentRay = refraction(newRay, hit, tts.xyz, normal, inior, outior, glossiness);
        //} else
        {
            emitentRay = diffuse(newRay, hit, tx.xyz, normal);
            diffused = true;
        }

        emitentRay.color.xyz *= 1.0f - prom;
        emitentRay.final.xyz *= 1.0f - prom;

#ifdef DIRECT_LIGHT
        if (diffused) applyLight(directLight(0, emitentRay, hit, vec3(1.0f), normal), emitentRay, surfacenormal);
#endif

        emitRay(emitentRay, hit, normal, 1.0f);
        newRay = promised(newRay, hit, normal);
        newRay.color.xyz *= amod;
    }

    storeHit(t, hit);
    storeRay(t, newRay);
}
