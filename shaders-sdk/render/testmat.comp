#version 460

#include "../include/constants.glsl"

#ifdef USE_BINDLESS
#extension GL_ARB_bindless_texture : require
#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

/* Atmosphere sky functions and parameters */
#define up vec3(0.0f, 1.0f, 0.0f)
#define atmosphereColor vec3(0.18, 0.49, 0.66)
#define rayleighAmmount .06*0.5
#define mieAmmount .002*0.5
#define atmosphereHeight .4*0.2
#define earthRadius 14.6*0.2
#define getThickness(a) js_getThickness(a)
#define getEarth(a) clamp( dot(up,a)*10.+1. ,0.,1.)
#define phaseRayleigh(a) (.059683104 * (1. + a * a))
#define phaseMie(a) (.0348151 / pow(1.5625 - 1.5*a,1.5))
#define absorb(a) (1. - pow(atmosphereColor, vec3(1./(a))))

LOCAL_SIZE_LAYOUT;

float js_getThickness(in vec3 rd){
     float sr = earthRadius+atmosphereHeight;
     vec3 ro = -up*earthRadius;
     float b = dot(rd, ro);
     float c = dot(ro, ro) - sr*sr;
     float t = b*b - c;
    return b + sqrt(t);
}

vec3 saturate(in vec3 c, in float s) {
    return c*s+dot(c, vec3(.2125, .7154, .0721) )*(1 - s);
}

vec3 js_getScatter(in vec3 V, in vec3 L, in float lightStrength) {
     float thicknessV = getThickness(V), dotVL = dot(V, L);
     vec3 sunColor = lightStrength * absorb(getThickness(L)) * getEarth(L);
     vec3 rayleighGradient = atmosphereColor * rayleighAmmount * phaseRayleigh(dotVL);
     float mieGradient = mieAmmount * phaseMie(dotVL);
    vec3 skyColor = (mieGradient + rayleighGradient) * absorb(thicknessV) * sunColor * thicknessV;
    skyColor += pow(max(dotVL,0.), 7000.) * sunColor; //sun
    return saturate(skyColor,1.3)*vec3(1,1,1.35);
}


float wave(in float n) {
    return sin(2 * PI * (n));
}

float mat(in float pos) {
    return fract(sin(pos)*43758.5453);
}

float Wnoise2D(in vec2 x, in float n){
     vec2 p = floor(x), f = fract(x);
     float m = p.x + p.y*n;
    return mix(mix(mat(m-1), mat(m),f.x), mix(mat(m+(n-1)), mat(m+n),f.x),f.y);
}

float waterH(in vec3 posxz, in float frameTimeCounter) {
    float noise = 0.0, freq = 1.0, amp = 1.0, n = 32.0;
     vec2 coord = -n+n*fract(posxz.xz / 1000.0), tock = vec2(frameTimeCounter / 100.0);
    for( int i = 0; i < 2; i++) {
        noise += Wnoise2D(-n+n*(coord + tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
        noise += Wnoise2D(-n+n*(coord - tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
    }
    return noise * 5.0;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);
    result = mat.diffuse;
    if (validateTexture(mat.diffusePart)) {
        result = fetchPart(mat.diffusePart, texcoord);
    }
    return result;
}

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    const bool overflow = it >= RAY_BLOCK samplerUniform.rayCount;
    if (overflow) return;
    //if (allInvocationsARB(overflow)) return;

    const int t = activedBuf.indc[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    if (overflow) newRay.actived = 0;

    Hit hit = fetchHitDirect(t);

    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        hit.shaded = 1;
    }

    int lc = -1;
    if (newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 ) && hit.shaded < 1) {
        for (int i=0;i<min(RAY_BLOCK materialUniform.lightcount, 16);i++) {
            float md = 1.0f;
            float dt = intersectSphere(newRay.origin.xyz, newRay.direct.xyz, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
            }
        }
    }

    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz * getLightColor(lc);
        newRay.color.xyz *= 0.0f;
        newRay.actived = 0;
        hit.shaded = 1;
    }

    {
        vec3 lcenter = lightCenterSky(0);
        vec3 color = readEnv(newRay.direct.xyz).xyz;//texture(skybox[0], newRay.direct.xyz * vec3(1.f, -1.f, 1.f)).xyz;
        /*
            js_getScatter(newRay.direct.xyz, -normalize(lcenter - newRay.origin.xyz), 800.0f) +
            js_getScatter(newRay.direct.xyz,  normalize(lcenter - newRay.origin.xyz), 4000.0f);
        color = (1.0f - exp(-1.0f * color));
        */
        if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1 && hit.shaded < 1) {
            newRay.final.xyz = newRay.color.xyz * color;
            newRay.color.xyz *= 0.0f;
            newRay.actived = 0;
            hit.triangle = 0;
            hit.dist = INFINITY;
            hit.materialID = LONGEST;
            hit.shaded = 1;
        }
    }

    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        hit.shaded = 1;
    }

    Submat materialCache = submats[hit.materialID];

    vec3 dir = normalize(newRay.direct.xyz);
    vec3 prenormal = normalize(hit.normal.xyz);
    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    vec3 surfacenormal = normal;
    vec3 tan = normalize(hit.tangent.xyz);
    mat3 tbn = mat3(tan, normalize(cross(normal, tan)), normal);
    normal = normalize(tbn * getNormalMapping(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);

    // construct orthonormal basis around N
    vec3 T1, T2;
    T1 = normalize(dir - normal*dot(dir, normal));
    T2 = normalize(cross(normal, T1));
    tbn_light = transpose(mat3(T1, T2, normal)), dirl = dir;

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    vec4 tts = 1.0f - clamp(fetchTransmission(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 sp = clamp(fetchSpecular(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 emi = materialCache.emissive * fetchEmissive(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal) * 2.f;
    vec3 dielectric = vec3(clamp(0.04f + pow(1.0f - abs(dot(dir, normal)), 5.0f), 0.0f, 1.0f));
    vec3 sc = mix(dielectric, tx.xyz, sqrt(sp.z));

    // we coming to PBR model
     float refly = sp.y; // roughness
     float emis = mlength(emi.xyz);
     float spca = mlength(sc.xyz);
     float spic = clamp(spca, 0.0f, 1.0f); // diffuse or specular (except AO?)
     float prom = 1.0f - tx.a;

    Ray diffuseRay = newRay;
    diffuseRay.final.xyz *= 0.0f;

    Ray reflectionRay = newRay;
    reflectionRay.final.xyz *= 0.0f;

    Ray emissiveRay = newRay;
    emissiveRay.final.xyz *= 0.0f;
    
    if (hit.shaded < 1) newRay.final.xyz *= 0.f;

    if (newRay.actived > 0 && hit.shaded < 1) {
        newRay.final.xyz *= 0.0f;

        diffuseRay = diffuse(diffuseRay, hit, tx.xyz, normal);
        diffuseRay.color.xyz *= (1.0f - prom);
        diffuseRay.color.xyz *= clamp(1.0f - emis, 0.0f, 1.0f);

        //spic = 0.f; // test purpose
        reflectionRay = reflection(reflectionRay, hit, clamp(sc.xyz / spca, 0.0f, 1.0f), normal, refly);
        reflectionRay.color.xyz *= (1.0f - prom);
        

        emissiveRay = emissive(emissiveRay, hit, emi.xyz / min(emis, 1.0f), normal);
        emissiveRay.color.xyz *= (1.0f - prom);
        emissiveRay.final.xyz *= (1.0f - prom);

        newRay = promised(newRay, hit, normal);
        newRay.color.xyz *= prom;

        hit.shaded = 1;
    } else {
        reflectionRay.color.xyz *= 0.0f;
        emissiveRay.color.xyz *= 0.0f;
        diffuseRay.color.xyz *= 0.0f;
    }

    if (!overflow) {
        //mixed(diffuseRay.color.xyz, reflectionRay.color.xyz, clamp(spic, 0.0f, 1.0f));
        mixed(diffuseRay.color.xyz, reflectionRay.color.xyz, clamp(float(random() < spic), 0.0f, 1.0f));
        emitRay(reflectionRay, hit, normal, 1.0f);
        applyLight(directLight(0, diffuseRay, hit, vec3(1.0f), normal), diffuseRay, surfacenormal); // push shadow
        emitRay(diffuseRay, hit, normal, 1.0f);
        emitRay(emissiveRay, hit, normal, clamp(emis, 0.0f, 1.0f));
    }

    if (!overflow) {
        storeHit(t, hit);
        storeRay(t, newRay);
    }
}
