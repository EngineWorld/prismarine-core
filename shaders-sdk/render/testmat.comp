#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require
//#extension GL_ARB_bindless_texture : require

#include "../include/constants.glsl"

//#ifndef USE_EMULATED
//#extension GL_ARB_bindless_texture : require
//#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
//#include "../include/textureManager.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

/* Atmosphere sky functions and parameters */
#define up vec3(0.0f, 1.0f, 0.0f)
#define atmosphereColor vec3(0.18, 0.49, 0.66)
#define rayleighAmmount .06*0.5
#define mieAmmount .002*0.5
#define atmosphereHeight .4*0.2
#define earthRadius 14.6*0.2
#define getThickness(a) js_getThickness(a)
#define getEarth(a) clamp( dot(up,a)*10.+1. ,0.,1.)
#define phaseRayleigh(a) (.059683104 * (1. + a * a))
#define phaseMie(a) (.0348151 / pow(1.5625 - 1.5*a,1.5))
#define absorb(a) (1. - pow(atmosphereColor, vec3(1./(a))))

LOCAL_SIZE_LAYOUT;

float js_getThickness(in vec3 rd){
     float sr = earthRadius+atmosphereHeight;
     vec3 ro = -up*earthRadius;
     float b = dot(rd, ro);
     float c = dot(ro, ro) - sr*sr;
     float t = b*b - c;
    return b + sqrt(t);
}

vec3 saturate(in vec3 c, in float s) {
    return c*s+dot(c, vec3(.2125, .7154, .0721) )*(1 - s);
}

vec3 js_getScatter(in vec3 V, in vec3 L, in float lightStrength) {
     float thicknessV = getThickness(V), dotVL = dot(V, L);
     vec3 sunColor = lightStrength * absorb(getThickness(L)) * getEarth(L);
     vec3 rayleighGradient = atmosphereColor * rayleighAmmount * phaseRayleigh(dotVL);
     float mieGradient = mieAmmount * phaseMie(dotVL);
    vec3 skyColor = (mieGradient + rayleighGradient) * absorb(thicknessV) * sunColor * thicknessV;
    skyColor += pow(max(dotVL,0.), 7000.) * sunColor; //sun
    return saturate(skyColor,1.3)*vec3(1,1,1.35);
}


float wave(in float n) {
    return sin(2 * PI * (n));
}

float mat(in float pos) {
    return fract(sin(pos)*43758.5453);
}

float Wnoise2D(in vec2 x, in float n){
     vec2 p = floor(x), f = fract(x);
     float m = p.x + p.y*n;
    return mix(mix(mat(m-1), mat(m),f.x), mix(mat(m+(n-1)), mat(m+n),f.x),f.y);
}

float waterH(in vec3 posxz, in float frameTimeCounter) {
    float noise = 0.0, freq = 1.0, amp = 1.0, n = 32.0;
     vec2 coord = -n+n*fract(posxz.xz / 1000.0), tock = vec2(frameTimeCounter / 100.0);
    for( int i = 0; i < 2; i++) {
        noise += Wnoise2D(-n+n*(coord + tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
        noise += Wnoise2D(-n+n*(coord - tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
    }
    return noise * 5.0;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);
    result = mat.diffuse;
    if (validateTexture(mat.diffusePart)) {
        result = fetchPart(mat.diffusePart, texcoord);
    }
    return result;
}

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    if (it >= RAY_BLOCK samplerUniform.rayCount) return;

    const int t = activedBuf.indc[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    Hit hit = fetchHitDirect(t);

    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        storeRay(t, newRay);
        return;
    }

    int lc = -1;
    bool lightedRay = newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 );
    //if (lightedRay) {
    if (newRay.params.z > 0) {
        for (int i=0;i<RAY_BLOCK materialUniform.lightcount;i++) {
            float md = 1.0f;
            float dt = intersectSphere(newRay.origin.xyz, newRay.direct.xyz, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
                hit.shaded = 1;
            }
        }
    }
    //}

    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz * getLightColor(lc) * float(lightedRay);
        newRay.actived = 0;
    }

    {
         vec3 lcenter = lightCenterSky(0);
        vec3 color = //vec3(0.1f);
            js_getScatter(newRay.direct.xyz, -normalize(lcenter - newRay.origin.xyz), 800.0f) +
            js_getScatter(newRay.direct.xyz,  normalize(lcenter - newRay.origin.xyz), 4000.0f);
        color = 1.0f - exp(-1.0f * color);

        if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1 && hit.shaded < 1) {
            newRay.final.xyz = newRay.color.xyz * color;
            newRay.actived = 0;

            hit.triangle = 0;
            hit.dist = INFINITY;
            hit.materialID = LONGEST;
            hit.shaded = 1;
        }
    }

    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        storeHit(t, hit);
        storeRay(t, newRay);
        return;
    }

    Submat materialCache = submats[hit.materialID];

     vec3 dir = normalize(newRay.direct.xyz);
     vec3 prenormal = normalize(hit.normal.xyz);

    float inior = 1.0f;
    float outior = materialCache.ior;
     float inside = dot(prenormal, dir);
    if (inside >= 0.0f) {
         float tmp = inior;
        inior = outior;
        outior = tmp;
    }

    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
     vec3 surfacenormal = normal;
     vec3 tan = normalize(hit.tangent.xyz);
     mat3 tbn = mat3(tan, normalize(cross(normal, tan)), normal);
    normal = normalize(tbn * getNormalMapping(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);

    // construct orthonormal basis around N
    vec3 T1, T2;
    T1 = normalize(dir - normal*dot(dir, normal));
    T2 = normalize(cross(normal, T1));
    tbn_light = transpose(mat3(T1, T2, normal)), dirl = dir;

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    vec4 tts = 1.0f - clamp(fetchTransmission(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 sp = clamp(fetchSpecular(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 emi = materialCache.emissive * fetchEmissive(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal) * 3.0f;
    vec3 dielectric = vec3(clamp(0.04f + pow(1.0f - abs(dot(dir, normal)), 5.0f), 0.0f, 1.0f));
    vec3 sc = mix(dielectric, tx.xyz, sp.z);

    // we coming to PBR model
     float refly = sp.y; // roughness
     float emis = mlength(emi.xyz);
     float spca = mlength(sc.xyz);
     float spic = clamp(spca, 0.0f, 1.0f); // diffuse or specular (except AO?)
     float fres = computeFresnel(hit.normal.xyz, newRay.direct.xyz, inior, outior) * (inside <= 0.0f ? 1.0f : 0.0f);
     float prom = 1.0f - tx.a;

    //newRay.final.xyz = newRay.color.xyz * normalize(normal.xyz) * 0.5f + 0.5f;
    //newRay.actived = 0;
    
    bool additiveBlend = false;
    if (newRay.actived > 0 && hit.shaded < 1) {
        // init emmitents
        Ray emitentRay = newRay;
        Ray reflectionRay = newRay;

        emitentRay.color.xyz *= (1.0f - prom);
        reflectionRay.color.xyz *= (1.0f - prom);

        // emit reflection ray
        reflectionRay = reflection(reflectionRay, hit, clamp(sc.xyz / spca, 0.0f, 1.0f), normal, refly);
        mixed(emitentRay.color.xyz, reflectionRay.color.xyz, clamp(spic, 0.0f, 1.0f));
        applyLight(directLight(0, reflectionRay, hit, vec3(1.0f), normal, refly), reflectionRay, surfacenormal); // push shadow for PBR reflection
        emitRay(reflectionRay, hit, normal, 1.0f);

        // emit light
        emitRay(emissive(emitentRay, hit, emi.xyz / min(emis, 1.0f), normal), hit, normal, clamp(emis, 0.0f, 1.0f));
        emitentRay.color.xyz *= clamp(1.0f - emis, 0.0f, 1.0f);

        // emit diffuse ray
        emitentRay = reflection(emitentRay, hit, tx.xyz, normal, 1.0f);//diffuse(emitentRay, hit, tx.xyz, normal);
        applyLight(directLight(0, emitentRay, hit, vec3(1.0f), normal, 1.0f), emitentRay, surfacenormal); // push shadow
        emitRay(emitentRay, hit, normal, 1.0f);

        // transparency ray 
        newRay = promised(newRay, hit, normal);
        newRay.color.xyz *= additiveBlend ? 1.0f : prom;
    }

    if (hit.shaded < 1) {
        hit.shaded = 1;
        storeHit(t, hit);
        storeRay(t, newRay);
    }
}
