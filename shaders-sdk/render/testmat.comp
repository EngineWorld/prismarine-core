#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/constants.glsl"

//#ifndef USE_EMULATED
//#extension GL_ARB_bindless_texture : require
//#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
//#include "../include/textureManager.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

/* Atmosphere sky functions and parameters */
#define up vec3(0.0f, 1.0f, 0.0f)
#define atmosphereColor vec3(0.18, 0.49, 0.66)
#define rayleighAmmount .06*0.5
#define mieAmmount .002*0.5
#define atmosphereHeight .4*0.2
#define earthRadius 14.6*0.2
#define getThickness(a) js_getThickness(a)
#define getEarth(a) clamp( dot(up,a)*10.+1. ,0.,1.)
#define phaseRayleigh(a) (.059683104 * (1. + a * a))
#define phaseMie(a) (.0348151 / pow(1.5625 - 1.5*a,1.5))
#define absorb(a) (1. - pow(atmosphereColor, vec3(1./(a))))

LOCAL_SIZE_LAYOUT;

float js_getThickness(in vec3 rd){
    const float sr = earthRadius+atmosphereHeight;
    const vec3 ro = -up*earthRadius;
    const float b = dot(rd, ro);
    const float c = dot(ro, ro) - sr*sr;
    const float t = b*b - c;
    return b + sqrt(t);
}

vec3 saturate(in vec3 c, in float s) {
    return c*s+dot(c, vec3(.2125, .7154, .0721) )*(1 - s);
}

vec3 js_getScatter(in vec3 V, in vec3 L, in float lightStrength) {
    const float thicknessV = getThickness(V), dotVL = dot(V, L);
    const vec3 sunColor = lightStrength * absorb(getThickness(L)) * getEarth(L);
    const vec3 rayleighGradient = atmosphereColor * rayleighAmmount * phaseRayleigh(dotVL);
    const float mieGradient = mieAmmount * phaseMie(dotVL);
    vec3 skyColor = (mieGradient + rayleighGradient) * absorb(thicknessV) * sunColor * thicknessV;
    skyColor += pow(max(dotVL,0.), 7000.) * sunColor; //sun
    return saturate(skyColor,1.3)*vec3(1,1,1.35);
}


float wave(in float n) {
    return sin(2 * PI * (n));
}

float mat(in float pos) {
    return fract(sin(pos)*43758.5453);
}

float Wnoise2D(in vec2 x, in float n){
    const vec2 p = floor(x), f = fract(x);
    const float m = p.x + p.y*n;
    return mix(mix(mat(m-1), mat(m),f.x), mix(mat(m+(n-1)), mat(m+n),f.x),f.y);
}

float waterH(in vec3 posxz, in float frameTimeCounter) {
    float noise = 0.0, freq = 1.0, amp = 1.0, n = 32.0;
    const vec2 coord = -n+n*fract(posxz.xz / 1000.0), tock = vec2(frameTimeCounter / 100.0);
    for( int i = 0; i < 2; i++) {
        noise += Wnoise2D(-n+n*(coord + tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
        noise += Wnoise2D(-n+n*(coord - tock)*freq, n)*amp; freq *= 2.1; amp *= 0.5;
    }
    return noise * 5.0;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);
    result = mat.diffuse;

    if(validateTexture(mat.diffusePart)) {
        result = fetchPart(mat.diffusePart, texcoord);
    }

    return result;
}

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    if (it >= RAY_BLOCK samplerUniform.rayCount) return;

    const int t = actived[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    Hit hit = fetchHitDirect(t);

    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        storeRay(t, newRay);
        return;
    }

    int lc = -1;
    for (int i=0;i<RAY_BLOCK materialUniform.lightcount;i++) {
        if ( newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 )) {
            float md = 1.0f;
            Ray tempRay = transformRay(newRay, md);
            const float dt = intersectSphere(tempRay.origin.xyz, tempRay.direct.xyz, lightCenter(i).xyz, lightUniform[i].lightColor.w + GAP);
            const float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
                hit.shaded = 1;
            }
        }
    }

    // light achieved?
    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz * getLightColor(lc);
        newRay.actived = 0;
    }

    if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1 && hit.shaded < 1) {
        newRay = transformRay(newRay);

        const vec3 lcenter = lightCenterSky(0);
        vec3 color = //vec3(0.8f, 0.9f, 1.0f);
            js_getScatter(newRay.direct.xyz, -normalize(lcenter - newRay.origin.xyz), 800.0f) +
            js_getScatter(newRay.direct.xyz,  normalize(lcenter - newRay.origin.xyz), 4000.0f);
        color = 1.0f - exp(-1.0f * color);

        newRay.final.xyz = newRay.color.xyz * color;
        newRay = unTransformRay(newRay);
        newRay.actived = 0;

        hit.triangle = 0;
        hit.dist = INFINITY;
        hit.materialID = LONGEST;
        hit.shaded = 1;
    }



    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        storeHit(t, hit);
        storeRay(t, newRay);
        return;
    }



    const uint l = gl_LocalInvocationID.x;
     Submat materialCache = submats[hit.materialID];
    hit.shaded = 1;

    const vec3 dir = normalize(newRay.direct.xyz);
    const vec3 prenormal = normalize(hit.normal.xyz);

    float inior = 1.0f;
    float outior = materialCache.ior;
    const float inside = dot(prenormal, dir);
    if (inside >= 0.0f) {
        const float tmp = inior;
        inior = outior;
        outior = tmp;
    }

    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    const vec3 surfacenormal = normal;
    const vec3 tan = normalize(hit.tangent.xyz);
    const mat3 tbn = mat3(tan, cross(normal, tan), normal);
    normal = normalize(tbn * getNormalMapping(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    vec4 tts = 1.0f - clamp(fetchTransmission(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 sp = clamp(fetchSpecular(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal), vec4(0.0f), vec4(1.0f));
    vec4 emi = materialCache.emissive * fetchEmissive(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    vec3 dielectric = vec3(0.2f);
    vec3 sc = mix(dielectric, tx.xyz, sp.z);

    // we coming to PBR model
    const float refly = clamp(1.0f - sp.y, 0.0f, 1.0f); // roughness
    const float emis = mlength(emi.xyz);
    const float spca = mlength(sc.xyz);
    const float spic = clamp(spca, 0.0f, 1.0f); // diffuse or specular (except AO?)
    const float fres = computeFresnel(hit.normal.xyz, newRay.direct.xyz, inior, outior) * (inside <= 0.0f ? 1.0f : 0.0f);
    const float prom = 1.0f - tx.a;

    bool additiveBlend = false;
    {
        // init emmitents
        Ray emitentRay = newRay;
        Ray reflectionRay = newRay;

        emitentRay.color.xyz *= (1.0f - prom);
        reflectionRay.color.xyz *= (1.0f - prom);

        // emit reflection ray
        reflectionRay = reflection(reflectionRay, hit, sc.xyz / spca, normal, refly);
        mixed(emitentRay.color.xyz, reflectionRay.color.xyz, spic);
        emitRay(reflectionRay, hit, normal, 1.0f);

        // diffuse and light emission
        bool shadowed = false;
        if (random() < emis) {
            emitentRay = emissive(emitentRay, hit, emi.xyz / min(emis, 1.0f), normal);
        } else {
            emitentRay = diffuse(emitentRay, hit, tx.xyz, normal); shadowed = true;
        }
        
        // emit ray
        if (shadowed) {
            applyLight(directLight(0, emitentRay, hit, vec3(1.0f), normal), emitentRay, surfacenormal); // push shadow
        }
        emitRay(emitentRay, hit, normal, 1.0f);

        // transparency ray 
        newRay = promised(newRay, hit, normal);
        newRay.color.xyz *= additiveBlend ? 1.0f : prom;
    }

    storeHit(t, hit);
    storeRay(t, newRay);
}
