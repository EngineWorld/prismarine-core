#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"

layout ( std430, binding = 9 ) readonly buffer NodesBlock { HlbvhNode Nodes[]; };
layout ( std430, binding = 17 ) restrict buffer CWFoundGroups { GroupFoundResult FoundGroupsChains[]; };

const vec3 padding = vec3(0.00001f);
const int STACK_SIZE = 16;
shared int deferredStack[WORK_SIZE][STACK_SIZE];
shared int deferredPtr[WORK_SIZE];

struct TResult {
    float dist;
    int triangleID;
    int materialID; // legacy
    float predist;
    vec4 uv;
};

vec3 projectVoxels(in vec3 orig) {
    vec4 nps = mult4(vec4(orig, 1.0f), GEOMETRY_BLOCK geometryUniform.transform);
    return nps.xyz / nps.w;
}

vec3 unprojectVoxels(in vec3 orig) {
    vec4 nps = mult4(vec4(orig, 1.0f), GEOMETRY_BLOCK geometryUniform.transformInv);
    return nps.xyz / nps.w;
}

#define SGN(v) v = idx

TResult traverse(in float distn, in vec3 origin, in vec3 direct, in Hit hit) {
    const uint L = gl_LocalInvocationID.x;

    TResult lastRes;
    lastRes.dist = INFINITY;
    lastRes.predist = INFINITY;
    lastRes.triangleID = LONGEST;
    lastRes.materialID = LONGEST;

    // deferred stack
    deferredPtr[L] = 0;
    deferredStack[L][0] = -1;

    // test constants
    int bakedStep = int(floor(1.f + hit.vmods.w));
    vec3 torig = projectVoxels(origin);
    vec3 tdirproj = mult4(vec4(direct, 0.0), GEOMETRY_BLOCK geometryUniform.transform).xyz;
    float dirlen = 1.0f / length(tdirproj);
    vec3 dirproj = normalize(tdirproj);

    // test with root node
    float near = INFINITY, far = INFINITY;
    float d = intersectCubeSingle(torig, dirproj, vec4(vec3(0.0f), 1.0f), vec4(1.0f), near, far);
    lastRes.predist = far * dirlen;

    // node indexing
    int prevLeaf = -1, idx = 0;

    // init state
    HlbvhNode node = Nodes[idx];
    bool validBox = lessF(d, INFINITY) && greaterEqualF(d, 0.0f), skip = false;
    for (int i=0;i<8192;i++) {
        //if (allInvocations(!validBox)) {
        if (!validBox) {
            break;
        }

        // is leaf
        if (node.pdata.x == node.pdata.y && validBox) {
            float near = INFINITY, far = INFINITY;
            intersectCubeSingle(torig, dirproj, node.box.mn, node.box.mx, near, far);

            // link chains
            int idx = atomicIncFt(true);
            if (prevLeaf == -1) { SGN(lastRes.triangleID); } else { SGN(FoundGroupsChains[prevLeaf].nextResult); }
            prevLeaf = idx;

            // add new head
            FoundGroupsChains[idx] = GroupFoundResult(-1, near * dirlen, ivec2(node.pdata.w, node.pdata.y));
        }

        // choice near box
        bool notLeaf = node.pdata.x != node.pdata.y && validBox;
        //if (allInvocations(notLeaf || !validBox || !skip)) { // synchronize SIMD
        //if (anyInvocation(notLeaf)) {
        if (notLeaf) {
            HlbvhNode lnode = Nodes[node.pdata.x];
            HlbvhNode rnode = Nodes[node.pdata.y];

            vec2 inf2 = vec2(INFINITY), nearsLR = inf2, farsLR = inf2;
            intersectCubeApart(torig, dirproj, lnode.box.mn, lnode.box.mx, nearsLR.x, farsLR.x);
            intersectCubeApart(torig, dirproj, rnode.box.mn, rnode.box.mx, nearsLR.y, farsLR.y);

            bvec2 isCube = and2(greaterThanEqual(farsLR, nearsLR), greaterThanEqual(farsLR, vec2(0.0f)));
            vec2 nears = mix(inf2, nearsLR, isCube), fars = mix(inf2, farsLR, isCube), hits = mix(nears, fars, lessThan(nears, vec2(0.0f)));

            bvec2 overlaps = 
                and2(bvec2(notLeaf), 
                and2(lessThanEqual(hits, vec2(INFINITY-PZERO)),
                and2(greaterThan(hits, -vec2(PZERO)),
                greaterThan(vec2(lastRes.predist), nears * dirlen - PZERO))));
            
            bool anyOverlap = any(overlaps);
            //if (anyInvocation(anyOverlap)) {
            if (anyOverlap) { 
                bool leftOrder = all(overlaps) ? lessEqualF(hits.x, hits.y) : overlaps.x;
                ivec2 leftright = mix(ivec2(-1), node.pdata.xy, overlaps);
                leftright = leftOrder ? leftright : leftright.yx;
                if (anyOverlap) {
                    if (deferredPtr[L] < STACK_SIZE && leftright.y != -1) {
                        atomicExchange(deferredStack[L][atomicAdd(deferredPtr[L], 1)], leftright.y);
                    }
                    idx = leftright.x;
                    skip = true;
                }
            }

            if (idx >= 0) node = Nodes[idx];
        }

        // go to parent 
        //if (allInvocations(!skip || !validBox)) { // synchronize SIMD
        if (!skip) {
            int ptr = atomicAdd(deferredPtr[L], -1)-1;
            bool valid = ptr >= 0;
            idx = valid ? atomicExchange(deferredStack[L][ptr], -1) : -1;
            validBox = validBox && valid && idx >= 0;
            if (idx >= 0) node = Nodes[idx];
        } skip = false;
    }

    return lastRes;
}

LOCAL_SIZE_LAYOUT;

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    const bool overflow = it >= RAY_BLOCK samplerUniform.rayCount;
    //if (allInvocations(overflow)) return;
    if (overflow) return;

    const int t = activedBuf.indc[it];
    Ray ray = fetchRayDirect(t);
    if (ray.actived < 1 || overflow) return;
    //if (allInvocations(ray.actived < 1 || overflow)) return;

    Hit hit = fetchHitDirect(t);
    TResult res = traverse(hit.dist, ray.origin.xyz, ray.direct.xyz, hit);

    hit.triangleID = res.triangleID;
    if (!overflow) storeHit(t, hit);

    if (hit.triangleID != -1 && !overflow) {
        collBuf.indc[atomicIncGt(true)] = t;
    }
}
