#version 450

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"

#define MB_PAGES 2

layout ( binding = 0, r32ui ) uniform uimage2D sampleflags;
layout ( binding = 2, rgba32f ) uniform image2D presampled;
LOCAL_SIZE_LAYOUT;

vec4 collectSamples(in Texel txiho){
    vec4 sampled = vec4(0.0f);
    int sid = txiho.EXT.y;
    for (int i=0;i<32;i++) {
        if (sid < 0 || sid == LONGEST) break; 
        ColorChain ch = chBuf.chains[sid];
        sampled += ch.color;
        sid = ch.cdata.x;
    }
    return sampled;
}

void main(){
    const int it = int(gl_GlobalInvocationID.x);
    const ivec2 wh = ivec2(RAY_BLOCK samplerUniform.sceneRes.xy);
    const ivec2 whs = ivec2(imageSize(presampled).xy);
    const vec2 aspect = vec2(wh) / vec2(whs);
    const ivec2 scl = ivec2(ceil(aspect));
    const ivec3 xyl = ivec3(it % whs.x, it / whs.x, 0);

    int samplecount = 0;
    ivec2 basis = ivec2(vec2(xyl.xy) * aspect);
    vec4 newc = vec4(0.0f, 0.0f, 0.0f, 1.0f);
    vec2 screen = vec2(xyl.xy);
    for(int x=-1;x<=scl.x;x++){
        for(int y=-1;y<=scl.y;y++){
            ivec2 cmp = basis + ivec2(x, y);
            if (
                cmp.x >= 0 && cmp.x < wh.x && 
                cmp.y >= 0 && cmp.y < wh.y
            ) {
                if (RAY_BLOCK cameraUniform.interlace == 1){
                    if ((abs(cmp.x + cmp.y) % 2) == RAY_BLOCK cameraUniform.interlaceStage) continue;
                }

                int ts = cmp.y * wh.x + cmp.x;
                vec2 surround = vec2(texelBuf.nodes[ts].coord.x, texelBuf.nodes[ts].coord.y) * vec2(whs);
                vec2 diff = surround - screen + 0.00001f;
                if (
                    diff.x >= 0.0f && diff.x < 1.0f &&
                    diff.y >= 0.0f && diff.y < 1.0f
                ) {
                    samplecount++;
                    newc.xyz += collectSamples(texelBuf.nodes[ts]).xyz;
                }
            }
            
        }
    }

    newc.xyz /= max((aspect.x * aspect.y), 1.0f);

    if (samplecount > 0) {
#ifndef MOTION_BLUR
        if (imageLoad(sampleflags, xyl.xy).x > 0) {
            imageStore(sampleflags, xyl.xy, uvec4(0));
            imageStore(presampled, xyl.xy, vec4(0.0f));
        }
#endif

        vec4 xsample = imageLoad(presampled, xyl.xy);
        {
#ifdef MOTION_BLUR
             float inpage = 1.0f / MB_PAGES;
             float outpage = 1.0f - inpage;
            xsample = fma(imageLoad(presampled, xyl.xy), vec4(outpage), newc * inpage);
#else
             float next = xsample.w + newc.w;
             float prev = xsample.w;
             float divisor = prev / next;
            xsample.xyz = fma(xsample.xyz, vec3(divisor), newc.xyz * (1.0f - divisor));
            xsample.w += newc.w;
#endif
        }

        imageStore(presampled, xyl.xy, vec4(xsample));
    }
}
