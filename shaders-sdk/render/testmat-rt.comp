#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require
//#extension GL_ARB_bindless_texture : require

#include "../include/constants.glsl"

//#ifndef USE_EMULATED
//#extension GL_ARB_bindless_texture : require
//#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
//#include "../include/textureManager.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

#define M_PARTICLE    (1 << 10)
#define M_ALPHA_TEST  (1 <<  9)
#define M_REFLECTIVE  (1 <<  8)
#define M_TRANSPARENT (1 <<  7)
#define M_SHADOWED    (1 <<  6)
#define M_DECAL       (1 <<  5)
#define M_ENVIRONMENT (1 <<  4)
#define M_TWO_SIDED   (1 <<  3)
#define M_ADDITIVE    (1 <<  2)
#define M_CLAMP_S     (1 <<  1)
#define M_CLAMP_T     (1 <<  0)

LOCAL_SIZE_LAYOUT;

const int GL_ALWAYS = 0;
const int GL_EQUAL = 1;
const int GL_GEQUAL = 2;
const int GL_GREATER = 3;
const int GL_LEQUAL = 4;
const int GL_LESS = 5;
const int GL_NEVER = 6;
const int GL_NOTEQUAL = 7;

bool alphaTest(in int func, in float ref, in float alpha) {
    if (func == GL_EQUAL) return alpha == ref;
    if (func == GL_GEQUAL) return alpha >= ref;
    if (func == GL_GREATER) return alpha > ref;
    if (func == GL_LEQUAL) return alpha <= ref;
    if (func == GL_LESS) return alpha < ref;
    if (func == GL_NEVER) return false;
    if (func == GL_NOTEQUAL) return alpha != ref;
    return true;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);

    if (haveProp(mat, M_ENVIRONMENT)) {
        vec4 reflected = vec4(reflect(normalize(direct), normal), 0.0f);
        reflected = inverse(RAY_BLOCK cameraUniform.camInv) * reflected;
        reflected.z += 1.0f;

         float m = 1.0f / (2.0f * length(reflected.xyz));
        texcoord.xy = fma(reflected.xy, vec2(m), vec2(0.5f));
    }

    //mat.diffuse.xyz += 0.2f;
    mat.diffuse.xyz *= 1.25f;
    mat.diffuse = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));

    if (!validateTexture(mat.diffusePart)) {
        result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    } else
    if (haveProp(mat, M_ADDITIVE)) {
        result = clamp(fetchPart(mat.diffusePart, texcoord), vec4(0.0f), vec4(1.0f));
    } else
    if (haveProp(mat, M_SHADOWED)) {
        result = clamp(fetchPart(mat.diffusePart, texcoord) * mat.diffuse, vec4(0.0f), vec4(1.0f));
        //result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    } else {
        result = clamp(fetchPart(mat.diffusePart, texcoord) * mat.diffuse, vec4(0.0f), vec4(1.0f));
        //result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    }
    
    return result;
}

void main() {
    const int it = int(gl_GlobalInvocationID.x);

    if (it >= RAY_BLOCK samplerUniform.rayCount) return;
    const int t = activedBuf.indc[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    Hit hit = fetchHitDirect(t);
    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        storeRay(t, newRay);
        return;
    }

    int lc = -1;
    for (int i=0;i<RAY_BLOCK materialUniform.lightcount;i++) {
        if ( newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 )) {
            float md = 1.0f;
             float dt = intersectSphere(newRay.origin.xyz, newRay.direct.xyz, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
             float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
                hit.shaded = 1;
            }
        }
    }

    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz * getLightColor(lc);
        newRay.actived = 0;
    }

    if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1) {
        newRay.actived = 0;
        newRay.final.xyz = newRay.color.xyz * vec3(0.0f);

        hit.triangle = 0;
        hit.dist = INFINITY;
        hit.materialID = LONGEST;
        hit.shaded = 1;
    }

    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        storeHit(t, hit);
        storeRay(t, newRay);
        return;
    }

     Submat materialCache = submats[hit.materialID];

     vec3 dir = normalize(newRay.direct.xyz);
     vec3 prenormal = normalize(hit.normal.xyz);
    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
     vec3 surfacenormal = normal;
     vec3 tan = normalize(hit.tangent.xyz);
     mat3 tbn = mat3(tan, normalize(cross(normal, tan)), normal);
    //normal = normalize(tbn * getNormalMapping(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);

    // construct orthonormal basis around N
    vec3 T1, T2;
    T1 = normalize(dir - normal*dot(dir, normal));
    T2 = cross(normal, T1);
    tbn_light = inverse(mat3(T1, T2, normal)), dirl = dir;

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    float prom = 1.0f - tx.a;
    if (false
        || haveProp(materialCache, M_ALPHA_TEST) && !alphaTest(materialCache.alphafunc, materialCache.alpharef, tx.a) 
        || !haveProp(materialCache, M_TWO_SIDED) && dot(prenormal, newRay.direct.xyz) > 0.0f
    ) {
        prom = 1.0f;
    }

    if (newRay.actived > 0 && hit.shaded < 1) {
        // diffuse
        bool shadowed = false;
        Ray emitentRay = newRay;
        Ray reflectionRay = newRay;

        emitentRay.color.xyz *= (1.0f - prom);

        if (haveProp(materialCache, M_ENVIRONMENT) && dot(hit.normal.xyz, emitentRay.direct.xyz) < 0.0f) {
            mixed(emitentRay.color.xyz, reflectionRay.color.xyz, 0.2f);
        } else {
            mixed(emitentRay.color.xyz, reflectionRay.color.xyz, 0.0f);
        }

        if (haveProp(materialCache, M_SHADOWED)) {
            emitentRay = diffuse(emitentRay, hit, tx.xyz, normal);
            shadowed = true;
        } else {
            emitentRay = emissive(emitentRay, hit, tx.xyz, normal);
        }
        if (shadowed) applyLight(directLight(0, emitentRay, hit, vec3(1.0f), normal), emitentRay, surfacenormal);
        emitRay(emitentRay, hit, normal, 1.0f);

        // reflective effects in coins and metals
        if (haveProp(materialCache, M_ENVIRONMENT) && dot(hit.normal.xyz, reflectionRay.direct.xyz) < 0.0f) {
            emitRay(reflection(reflectionRay, hit, vec3(1.0f), normal, 0.99f), hit, normal, 1.0f);
        }

        // transparency or reflection ray
        if (!haveProp(materialCache, M_ADDITIVE)) { 
            newRay.color.xyz *= prom; 
        }
        if ( haveProp(materialCache, M_REFLECTIVE)) { // mirrors
            newRay = reflection(newRay, hit, vec3(1.0f), normal, 1.0f);
        } else { // transparency
            newRay = promised(newRay, hit, normal);
        }
    }

    if (hit.shaded < 1) {
        hit.shaded = 1;
        storeHit(t, hit);
        storeRay(t, newRay);
    }
}
