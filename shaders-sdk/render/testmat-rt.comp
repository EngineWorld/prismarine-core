#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/constants.glsl"

//#ifndef USE_EMULATED
//#extension GL_ARB_bindless_texture : require
//#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
//#include "../include/textureManager.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

#define M_PARTICLE    (1 << 10)
#define M_ALPHA_TEST  (1 <<  9)
#define M_REFLECTIVE  (1 <<  8)
#define M_TRANSPARENT (1 <<  7)
#define M_SHADOWED    (1 <<  6)
#define M_DECAL       (1 <<  5)
#define M_ENVIRONMENT (1 <<  4)
#define M_TWO_SIDED   (1 <<  3)
#define M_ADDITIVE    (1 <<  2)
#define M_CLAMP_S     (1 <<  1)
#define M_CLAMP_T     (1 <<  0)

LOCAL_SIZE_LAYOUT;

const int GL_ALWAYS = 0;
const int GL_EQUAL = 1;
const int GL_GEQUAL = 2;
const int GL_GREATER = 3;
const int GL_LEQUAL = 4;
const int GL_LESS = 5;
const int GL_NEVER = 6;
const int GL_NOTEQUAL = 7;

bool alphaTest(in int func, in float ref, in float alpha) {
    if (func == GL_EQUAL) return alpha == ref;
    if (func == GL_GEQUAL) return alpha >= ref;
    if (func == GL_GREATER) return alpha > ref;
    if (func == GL_LEQUAL) return alpha <= ref;
    if (func == GL_LESS) return alpha < ref;
    if (func == GL_NEVER) return false;
    if (func == GL_NOTEQUAL) return alpha != ref;
    return true;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);

    if (haveProp(mat, M_ENVIRONMENT)) {
        vec4 reflected = vec4(reflect(normalize(direct), normal), 0.0f);
        reflected = inverse(RAY_BLOCK cameraUniform.camInv) * reflected;
        reflected.z += 1.0f;

        const float m = 1.0f / (2.0f * length(reflected.xyz));
        texcoord.xy = fma(reflected.xy, vec2(m), vec2(0.5f));
    }

    //mat.diffuse.xyz += 0.2f;
    mat.diffuse.xyz *= 1.25f;
    mat.diffuse = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));

    if (!validateTexture(mat.diffusePart)) {
        result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    } else
    if (haveProp(mat, M_ADDITIVE)) {
        result = clamp(fetchPart(mat.diffusePart, texcoord), vec4(0.0f), vec4(1.0f));
    } else
    if (haveProp(mat, M_SHADOWED)) {
        result = clamp(fetchPart(mat.diffusePart, texcoord) * mat.diffuse, vec4(0.0f), vec4(1.0f));
        //result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    } else {
        result = clamp(fetchPart(mat.diffusePart, texcoord) * mat.diffuse, vec4(0.0f), vec4(1.0f));
        //result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    }

    result.xyz = pow(result.xyz, vec3(GAMMA));
    return result;
}

void main() {
    const int it = int(gl_GlobalInvocationID.x);

    if (it >= RAY_BLOCK samplerUniform.rayCount) return;
    const int t = actived[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    Hit hit = fetchHitDirect(t);
    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        storeRay(t, newRay);
        return;
    }

    int lc = -1;
    for (int i=0;i<RAY_BLOCK materialUniform.lightcount;i++) {
        if ( newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 )) {
            float md = 1.0f;
            Ray tempRay = transformRay(newRay, md);
            const float dt = intersectSphere(tempRay.origin.xyz, tempRay.direct.xyz, lightCenter(i).xyz, lightUniform[i].lightColor.w + GAP);
            const float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
                hit.shaded = 1;
            }
        }
    }

    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz * getLightColor(lc);
        newRay.actived = 0;
    }

    if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1) {
        newRay.actived = 0;
        newRay.final.xyz = newRay.color.xyz * vec3(0.0f);

        hit.triangle = 0;
        hit.dist = INFINITY;
        hit.materialID = LONGEST;
        hit.shaded = 1;
    }

    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        storeHit(t, hit);
        storeRay(t, newRay);
        return;
    }

    const uint l = gl_LocalInvocationID.x;
     Submat materialCache = submats[hit.materialID];
    hit.shaded = 1;

    const vec3 dir = normalize(newRay.direct.xyz);
    const vec3 prenormal = normalize(hit.normal.xyz);
    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    const vec3 surfacenormal = normal;
    const vec3 tan = normalize(hit.tangent.xyz);
    const mat3 tbn = mat3(tan, cross(normal, tan), normal);
    //normal = normalize(tbn * getNormalMapping(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal));
    normal = faceforward(normal, dir, normal);

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    bool diffused = false;

    float prom = 1.0f - tx.a;
    if (
        haveProp(materialCache, M_ALPHA_TEST) && !alphaTest(materialCache.alphafunc, materialCache.alpharef, tx.a) 
        //|| !haveProp(materialCache, M_TWO_SIDED) && dot(prenormal, newRay.direct.xyz) > 0.0f
    ) {
        prom = 1.0f;
    }

    {
        // diffuse
        Ray emitentRay = newRay;
        if (haveProp(materialCache, M_SHADOWED)) {
            emitentRay = diffuse(newRay, hit, tx.xyz, normal);
            diffused = true;
        } else {
            emitentRay = emissive(newRay, hit, tx.xyz, normal);
        }

        emitentRay.color.xyz *= (1.0f - prom);
        emitentRay.final.xyz *= (1.0f - prom);

        // reflective effects in coins and metals
        //if (haveProp(materialCache, M_ENVIRONMENT) && dot(hit.normal.xyz, newRay.direct.xyz) < 0.0f) {
        //    emitRay(reflection(newRay, hit, vec3(1.0f), normal, 0.0f), hit, normal, 0.2f);
        //    emitentRay.color.xyz *= 0.8f;
        //}

        // emit diffuse ray
        if (prom < 1.f) {
#ifdef DIRECT_LIGHT
            if (diffused) applyLight(directLight(0, emitentRay, hit, vec3(1.0f), normal), emitentRay, surfacenormal);
#endif
            emitRay(emitentRay, hit, normal, 1.0f);
        }

        if ( haveProp(materialCache, M_REFLECTIVE)) { // mirrors
            newRay = reflection(newRay, hit, vec3(1.0f), normal, 0.0f);
        } else { // transparency
            newRay = promised(newRay, hit, normal);
        }

        // push transparency ray
        if (!haveProp(materialCache, M_ADDITIVE)) {
            newRay.color.xyz *= prom;
        }
    }

    storeHit(t, hit);
    storeRay(t, newRay);
}
