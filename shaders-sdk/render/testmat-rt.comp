#version 450

#extension GL_ARB_bindless_texture : require

#include "../include/constants.glsl"

//#ifndef USE_EMULATED
//#extension GL_ARB_bindless_texture : require
//#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/random.glsl"
//#include "../include/textureManager.glsl"
#include "../include/STOmath.glsl"
#include "../include/materialFunc.glsl"

#define M_COIN        (1 << 11)
#define M_PARTICLE    (1 << 10)
#define M_ALPHA_TEST  (1 <<  9)
#define M_REFLECTIVE  (1 <<  8)
#define M_TRANSPARENT (1 <<  7)
#define M_SHADOWED    (1 <<  6)
#define M_DECAL       (1 <<  5)
#define M_ENVIRONMENT (1 <<  4)
#define M_TWO_SIDED   (1 <<  3)
#define M_ADDITIVE    (1 <<  2)
#define M_CLAMP_S     (1 <<  1)
#define M_CLAMP_T     (1 <<  0)

LOCAL_SIZE_LAYOUT;

const int GL_ALWAYS = 0;
const int GL_EQUAL = 1;
const int GL_GEQUAL = 2;
const int GL_GREATER = 3;
const int GL_LEQUAL = 4;
const int GL_LESS = 5;
const int GL_NEVER = 6;
const int GL_NOTEQUAL = 7;

bool alphaTest(in int func, in float ref, in float alpha) {
    if (func == GL_EQUAL) return alpha == ref;
    if (func == GL_GEQUAL) return alpha >= ref;
    if (func == GL_GREATER) return alpha > ref;
    if (func == GL_LEQUAL) return alpha <= ref;
    if (func == GL_LESS) return alpha < ref;
    if (func == GL_NEVER) return false;
    if (func == GL_NOTEQUAL) return alpha != ref;
    return true;
}

vec4 fetchDiffuse(in Submat mat, in vec2 texcoord, in vec3 direct, in vec3 normal){
    vec4 result = vec4(0.0f);

    if (haveProp(mat, M_ENVIRONMENT)) {
        vec4 reflected = vec4(reflect(normalize(direct), normal), 0.0f);
        reflected = inverse(RAY_BLOCK cameraUniform.camInv) * reflected;
        reflected.z += 1.0f;

         float m = 1.0f / (2.0f * length(reflected.xyz));
        texcoord.xy = fma(reflected.xy, vec2(m), vec2(0.5f));
    }

    bool isCoin = haveProp(mat, M_COIN);
    if (!isCoin) {
        mat.diffuse.xyz *= 1.25f;
    }

    if (!validateTexture(mat.diffusePart)) {
        result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    } else
    if (haveProp(mat, M_ADDITIVE)) {
        result = clamp(fetchPart(mat.diffusePart, texcoord), vec4(0.0f), vec4(1.0f));
    } else
    if (haveProp(mat, M_SHADOWED)) {
        result = clamp(fetchPart(mat.diffusePart, texcoord) * mat.diffuse, vec4(0.0f), vec4(1.0f));
        //result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    } else {
        result = clamp(fetchPart(mat.diffusePart, texcoord) * mat.diffuse, vec4(0.0f), vec4(1.0f));
        //result = clamp(mat.diffuse, vec4(0.0f), vec4(1.0f));
    }
    
    return result;
}



// TODO update shader for Neverball with WARP optimization

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    const bool overflow = it >= RAY_BLOCK samplerUniform.rayCount;

    if (overflow) return;
    //if (allInvocationsARB(overflow)) return;
    const int t = activedBuf.indc[it];
    globalInvocationSMP = it;

    Ray newRay = fetchRayDirect(t);
    if (overflow) newRay.actived = 0;

    Hit hit = fetchHitDirect(t);

    if (hit.shaded > 0 || newRay.actived < 1) { // already shaded, waiting
        hit.shaded = 1;
    }

    int lc = -1;
    if (newRay.params.x < 1 && (newRay.params.z > 0 || newRay.params.w > 0 ) && hit.shaded < 1) {
        for (int i=0;i<min(RAY_BLOCK materialUniform.lightcount, 16);i++) {
            float md = 1.0f;
            float dt = intersectSphere(newRay.origin.xyz, newRay.direct.xyz, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, hit.dist)) {
                lc = i;
                hit.triangle = 0;
                hit.dist = t;
                hit.materialID = LONGEST;
            }
        }
    }

    if (lc >= 0 && (newRay.params.y == lc || newRay.params.w < 1)){
        newRay.final.xyz = newRay.color.xyz;//* getLightColor(lc);
        newRay.color.xyz *= 0.0f;
        newRay.actived = 0;
        hit.shaded = 1;
    }

    if (greaterEqualF(hit.dist, INFINITY) && newRay.params.w < 1 && hit.shaded < 1) {
        newRay.final.xyz = newRay.color.xyz * vec3(0.f);
        newRay.color.xyz *= 0.0f;
        newRay.actived = 0;
        hit.triangle = 0;
        hit.dist = INFINITY;
        hit.materialID = LONGEST;
        hit.shaded = 1;
    }

    newRay.direct.xyz = normalize(newRay.direct.xyz);
    newRay.origin.xyz = fma(newRay.direct.xyz, vec3(hit.dist), newRay.origin.xyz);

    if (hit.materialID < 0 || hit.materialID == LONGEST || hit.shaded > 0 || newRay.actived < 1) {
        hit.shaded = 1;
    }

    Submat materialCache = submats[hit.materialID];

    vec3 dir = normalize(newRay.direct.xyz);
    vec3 prenormal = normalize(hit.normal.xyz);
    vec3 normal = normalize(faceforward(prenormal, dir, prenormal));
    vec3 surfacenormal = normal;
    vec3 tan = normalize(hit.tangent.xyz);
    mat3 tbn = mat3(tan, normalize(cross(normal, tan)), normal);
    normal = faceforward(normal, dir, normal);

    // construct orthonormal basis around N
    vec3 T1, T2;
    T1 = normalize(dir - normal*dot(dir, normal));
    T2 = cross(normal, T1);
    tbn_light = transpose(mat3(T1, T2, normal)), dirl = dir;

    vec4 tx = fetchDiffuse(materialCache, hit.texcoord.xy, newRay.direct.xyz, normal);
    tx *= vec4(hit.vcolor.xyz, hit.vcolor.a);

    float prom = 1.0f - tx.a;
    if (false
        || haveProp(materialCache, M_ALPHA_TEST) && !alphaTest(materialCache.alphafunc, materialCache.alpharef, tx.a) 
        || !haveProp(materialCache, M_TWO_SIDED) && dot(prenormal, newRay.direct.xyz) > 0.0f
    ) {
        prom = 1.0f;
    }

    if ( haveProp(materialCache, M_REFLECTIVE)) {
        prom = mix(clamp(pow(1.0f - abs(dot(dir, normal)), 5.0f), 0.0f, 1.0f), 1.0f, prom);
    }



    Ray metallicRay = newRay;
    metallicRay.final.xyz *= 0.f;

    Ray diffuseRay = newRay;
    diffuseRay.final.xyz *= 0.f;

    Ray emissiveRay = newRay;
    emissiveRay.final.xyz *= 0.f;

    if (hit.shaded < 1) newRay.final.xyz *= 0.f;

    bool metallicSystem = haveProp(materialCache, M_ENVIRONMENT) || haveProp(materialCache, M_COIN);
    //bool isMetallic = haveProp(materialCache, M_ENVIRONMENT);
    if (newRay.actived > 0 && hit.shaded < 1) {
        newRay.final.xyz *= 0.0f;

        metallicRay = reflection(metallicRay, hit, vec3(1.0f), normal, 0.00f);
        metallicRay.color.xyz *= (1.0f - prom);

        emissiveRay = emissive(emissiveRay, hit, tx.xyz, normal);
        emissiveRay.color.xyz *= (1.0f - prom);
        emissiveRay.final.xyz *= (1.0f - prom);

        vec3 tmpcol = vec3(1.0f);
        mixed(diffuseRay.color.xyz, metallicRay.color.xyz, float(metallicSystem) * mix(clamp(pow(1.0f - abs(dot(dir, normal)), 5.0f), 0.0f, 1.0f), 1.0f, 0.2f));
        //metallicRay.color.xyz *= 0.f;

        //diffuseRay = diffuse(diffuseRay, hit, tx.xyz, normal);
        diffuseRay = emissive(diffuseRay, hit, tx.xyz, normal);
        diffuseRay.color.xyz *= (1.0f - prom);
        diffuseRay.final.xyz *= (1.0f - prom);

        if (haveProp(materialCache, M_SHADOWED)) {
            emissiveRay.color.xyz *= 0.f;
            emissiveRay.final.xyz *= 0.f;
        } else {
            diffuseRay.color.xyz *= 0.f;
            diffuseRay.final.xyz *= 0.f;
        }

        newRay.color.xyz *= haveProp(materialCache, M_ADDITIVE) ? 1.f : prom;
        if ( haveProp(materialCache, M_REFLECTIVE)) { // mirrors
            newRay = reflection(newRay, hit, vec3(1.0f), normal, 0.00f);
        } else { // transparency
            newRay = promised(newRay, hit, normal);
        }

        hit.shaded = 1;
    } else {
        metallicRay.color.xyz *= 0.f;
        diffuseRay.color.xyz *= 0.f;
        diffuseRay.final.xyz *= 0.f;
        emissiveRay.color.xyz *= 0.f;
    }

    if (!overflow) {
        int lightcount = int(min(RAY_BLOCK materialUniform.lightcount, 16));

        for (int i=0;i<lightcount;i++) {
            vec3 lightColor = lightUniform.lightNode[i].lightAmbient.xyz * 0.6f;
            if (metallicSystem) {
                lightColor = getLightColor(i) * 0.6f;
            }
            applyLight(directLightWhitted(i, diffuseRay, hit, lightColor, normal), diffuseRay, surfacenormal);
        }

        diffuseRay.final.xyz *= 0.2f;
        //diffuseRay.final.xyz *= metallicSystem ? 0.f : 0.2f;

        emitRay(diffuseRay, hit, normal, 1.0f);
        emitRay(emissiveRay, hit, normal, 1.0f);
        emitRay(metallicRay, hit, normal, 1.0f);
    }

    if (!overflow) {
        storeHit(t, hit);
        storeRay(t, newRay);
    }
}
