#version 460

#define ORDERING_NOT_REQUIRED

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"
#include "../include/traverse.glsl"

struct LResult {
    vec4 normal;
    vec4 tangent;
    vec4 texcoord;
    vec4 color;
    vec4 mods;

    float dist;
    int triangle;
    int materialID;
    float predist; // legacy
    vec4 uv; // legacy
};

LResult loadInfo(in TResult hitp) {
    LResult res;
    res.dist = hitp.dist;
    res.triangle = hitp.triangle;
    res.materialID = -1;
    res.predist = hitp.predist; // legacy
    res.uv = hitp.uv; // legacy

    int tri = hitp.triangle;
    if (greaterEqualF(hitp.dist, 0.0f) && lessF(hitp.dist, INFINITY) && tri != LONGEST) {
        vec3 trinorms[3];
        vec3 triverts[3];
        vec4 texcoords[3];
        vec4 colors[3];
        vec4 mods[3];

        for (int x=0;x<3;x++) {
            ivec2 mos = gatherMosaic(getUniformCoord(tri));
            triverts[x] = fetchMosaic(vertex_texture, mos, x).xyz;
            trinorms[x] = fetchMosaic(normal_texture, mos, x).xyz;
            texcoords[x] = fetchMosaic(texcoords_texture, mos, x);
            colors[x] = vec4(1.0f);
            mods[x] = fetchMosaic(modifiers_texture, mos, x);
        }

        vec3 deltaPos1 = triverts[1] - triverts[0];
        vec3 deltaPos2 = triverts[2] - triverts[0];
        vec2 uv = hitp.uv.xy;
        vec3 nor = normalize(cross(deltaPos1, deltaPos2));
        vec3 normal = fma(trinorms[0], vec3(1.0f - uv.x - uv.y), fma(trinorms[1], vec3(uv.x), trinorms[2] * vec3(uv.y)));
        normal = lessF(length(normal), 0.f) ? nor : normalize(normal);
        normal = normal * sign(dot(normal, nor));

        bool delta = all(equal(texcoords[0].xy, texcoords[1].xy)) && all(equal(texcoords[0].xy, texcoords[2].xy));
        vec2 deltaUV1 = delta ? vec2(1.0f, 0.0f) : texcoords[1].xy - texcoords[0].xy;
        vec2 deltaUV2 = delta ? vec2(0.0f, 1.0f) : texcoords[2].xy - texcoords[0].xy;

        float f = 1.0f / fma(deltaUV1.x, deltaUV2.y, -deltaUV1.y * deltaUV2.x);
        vec3 tan = fma(deltaPos1, vec3(deltaUV2.y), -deltaPos2 * deltaUV1.y) * f;

        res.normal = vec4(normal, 0.0f);
        res.tangent = vec4(normalize(tan - normal * sign(dot(tan, nor))), 0.0f);
        res.texcoord = fma(texcoords[0], vec4(1.0f - uv.x - uv.y), fma(texcoords[1], vec4(uv.x), texcoords[2] * vec4(uv.y)));
        res.color = fma(colors[0], vec4(1.0f - uv.x - uv.y), fma(colors[1], vec4(uv.x), colors[2] * vec4(uv.y)));
        res.mods = fma(mods[0], vec4(1.0f - uv.x - uv.y), fma(mods[1], vec4(uv.x), mods[2] * vec4(uv.y)));
        res.materialID = mats[tri];
    }

    return res;
}

LOCAL_SIZE_LAYOUT;

void main() {
    const int it = int(gl_GlobalInvocationID.x);
    const bool overflow = it >= RAY_BLOCK samplerUniform.rayCount;
    if (allInvocations(overflow)) return;

    const int t = activedBuf.indc[it];
    Ray ray = fetchRayDirect(t);
    if (allInvocations(ray.actived < 1 || overflow)) return;

    Hit hit = fetchHitDirect(t);
    LResult res = loadInfo(traverse(hit.dist, ray.origin.xyz, ray.direct.xyz, hit));

    if (
        greaterEqualF(res.dist, 0.0f) &&
        lessF(res.dist, INFINITY) &&

        (lessEqualF(res.dist, hit.dist) || GEOMETRY_BLOCK geometryUniform.clearDepth > 0) &&
        
        res.materialID >= 0 &&
        res.materialID != LONGEST
    ) {
        Hit newHit = hit;
        vec4 sysmod = newHit.vmods;

        newHit.normal = res.normal;
        newHit.tangent = res.tangent;
        newHit.texcoord = res.texcoord;
        newHit.vcolor = res.color;
        newHit.vmods = res.mods;
        newHit.dist = res.dist;
        newHit.triangle = res.triangle;
        newHit.materialID = res.materialID;
        newHit.shaded = 0;

        newHit.vmods.w = sysmod.w;

        if (!overflow) storeHit(t, newHit);
    }
}
