#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/STOmath.glsl"

#if defined(ENABLE_AMD_INSTRUCTION_SET) || defined(ENABLE_NVIDIA_INSTRUCTION_SET)
#define INDEX16 uint16_t
#define M16(m, i) (m[i])
#else
#define INDEX16 uint
#define M16(m, i) (bitfieldExtract(m[i/2], int(16*(i%2)), 16))
#endif

#ifdef ENABLE_INT16_LOADING
#define INDICE_T INDEX16
#define PICK(m, i) M16(m, i)
#else
#define INDICE_T uint
#define PICK(m, i) m[i]
#endif

layout ( std430, binding=0)  buffer TCounterSSBO {int tcounter[];};
layout ( std430, binding=6) readonly buffer InputVertexSSBO {float iverts[];};
layout ( std430, binding=7) readonly buffer InputVertexIndicesSSBO {INDICE_T vindics[];};
layout ( std430, binding=8) readonly buffer InputMaterialsSSBO {int imats[];};
LOCAL_SIZE_LAYOUT;

const int m[3] = {3, 0, 2};
const int ms[3] = {2, 1, 3};

void main()
{
    if (gl_GlobalInvocationID.x >= GEOMETRY_BLOCK geometryUniform.triangleCount) return;

    const int ctriangle = int(gl_GlobalInvocationID.x);
    //const int matID = GEOMETRY_BLOCK geometryUniform.materialID;
    const int matID = imats[ctriangle] + GEOMETRY_BLOCK geometryUniform.materialID;
    vec3 vertice[4] = {vec3(0.0f), vec3(0.0f), vec3(0.0f), vec3(0.0f)};
    vec3 normal[4] = {vec3(0.0f), vec3(0.0f), vec3(0.0f), vec3(0.0f)};
    vec4 texcoord[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
    vec4 colors[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
    vec4 mods[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};

    const int mode = GEOMETRY_BLOCK attributeUniform.mode;
    const int trp = mode == 1 ? 4 : 3;
    for(int i=0;i<trp;i++){
        const uint ctri = ctriangle * trp + i;
        const uint ptri = uint(GEOMETRY_BLOCK geometryUniform.loadOffset) + ctri;
        const uint vindices = GEOMETRY_BLOCK geometryUniform.unindexed == 1 ? ptri : uint( PICK(vindics, ptri) );
        const uint stride = GEOMETRY_BLOCK attributeUniform.stride;

        vec3 vpos = vec3(0.0f);
        vec4 vtex = vec4(0.0f);
        vec3 vnorm = vec3(0.0f);
        vec4 color = vec4(1.0f);
        vec4 modf = vec4(0.0f);

        {
            const bool is2D = GEOMETRY_BLOCK attributeUniform.iModifiers0.z == 1;
            const uint vstride = stride <= 0 ? (is2D ? 2 : 3) : stride;
            vpos = vec3(
                iverts[(vindices) * vstride + GEOMETRY_BLOCK attributeUniform.vertexOffset + 0],
                iverts[(vindices) * vstride + GEOMETRY_BLOCK attributeUniform.vertexOffset + 1],

                // Z-coordinate
                is2D ? 0.00001f :
                iverts[(vindices) * vstride + GEOMETRY_BLOCK attributeUniform.vertexOffset + 2]
            );

            if (GEOMETRY_BLOCK attributeUniform.haveNormal > 0) {
                const uint nstride = stride <= 0 ? 3 : stride;
                vnorm = vec3(
                    iverts[(vindices) * nstride + GEOMETRY_BLOCK attributeUniform.normalOffset + 0],
                    iverts[(vindices) * nstride + GEOMETRY_BLOCK attributeUniform.normalOffset + 1],
                    iverts[(vindices) * nstride + GEOMETRY_BLOCK attributeUniform.normalOffset + 2]
                );
            }

            if (GEOMETRY_BLOCK attributeUniform.haveColor > 0) {
                if (GEOMETRY_BLOCK attributeUniform.colorFormat == 0) {
                    const uint cstride = stride <= 0 ? 4 : stride;
                    color = vec4(
                        iverts[(vindices) * cstride + GEOMETRY_BLOCK attributeUniform.colorOffset + 0],
                        iverts[(vindices) * cstride + GEOMETRY_BLOCK attributeUniform.colorOffset + 1],
                        iverts[(vindices) * cstride + GEOMETRY_BLOCK attributeUniform.colorOffset + 2],
                        iverts[(vindices) * cstride + GEOMETRY_BLOCK attributeUniform.colorOffset + 3]
                    );
                } else
                if (GEOMETRY_BLOCK attributeUniform.colorFormat == 1) {
                    color = unpackUnorm4x8(floatBitsToUint(iverts[(vindices) * stride + GEOMETRY_BLOCK attributeUniform.colorOffset]));
                }
            }


            vec2 tx = vec2(0.0f);
            if (GEOMETRY_BLOCK attributeUniform.haveTexcoord > 0) {
                const uint tstride = stride <= 0 ? 2 : stride;
                tx.x = iverts[(vindices) * tstride + GEOMETRY_BLOCK attributeUniform.texcoordOffset + 0];
                tx.y = iverts[(vindices) * tstride + GEOMETRY_BLOCK attributeUniform.texcoordOffset + 1];
#ifdef INVERT_TX_Y
                tx.y = 1.0f - tx.y; // invert Y
#endif
            }

            vec2 lt = vec2(0.0f);
            if (GEOMETRY_BLOCK attributeUniform.haveLightcoord > 0) {
                if (GEOMETRY_BLOCK attributeUniform.iModifiers0.x == 1) {

                    const uint bits = floatBitsToUint(iverts[(vindices) * stride + GEOMETRY_BLOCK attributeUniform.lightcoordOffset]);
                    const ivec3 bts = ivec3(
                        (bits >> 4) & 0xF,
                        (bits >> 20) & 0xF,
                        0
                    );
                    lt.xy = vec2(bts.x / 15.f, bts.z);

                } else {
                    const uint lstride = stride <= 0 ? 2 : stride;
                    lt.x = iverts[(vindices) * lstride + GEOMETRY_BLOCK attributeUniform.lightcoordOffset + 0];
                    lt.y = iverts[(vindices) * lstride + GEOMETRY_BLOCK attributeUniform.lightcoordOffset + 1];
                }
            }

            vec2 ml = vec2(0.0f);
            if (GEOMETRY_BLOCK attributeUniform.iModifiers0.y == 1) {
                const uint nstride = stride <= 0 ? 1 : stride;
                ml.xy = unpackUnorm2x16(floatBitsToUint(iverts[(vindices) * nstride + GEOMETRY_BLOCK attributeUniform.iModifiers1.y]));
            }

            vec4 txf = vec4(tx.xy, 0.0f, 1.0f) * GEOMETRY_BLOCK geometryUniform.texmatrix;
            txf /= txf.w;

            vtex = vec4(txf.xy, lt);
            modf = vec4(ml, vec2(0.0f));
        }

        vec4 normalf  = mult4(vec4(vnorm, 0.0f), GEOMETRY_BLOCK geometryUniform.transformInv);
        vec4 verticef = mult4(vec4(vpos , 1.0f), GEOMETRY_BLOCK geometryUniform.transform);
        verticef.xyz /= verticef.w;

        vertice[i] = verticef.xyz;
        normal[i] = normalf.xyz;
        texcoord[i] = vtex;
        colors[i] = color;
        mods[i] = modf;
    }

    // adapt quads to triangles
    const int istride = mode == 1 ? 2 : 1;
    int tidc = GEOMETRY_BLOCK geometryUniform.triangleOffset + int(gl_GlobalInvocationID.x) * istride;
    atomicAdd(tcounter[0], istride);

    vec3 offsetnormal = normalize(cross(vertice[1] - vertice[0], vertice[2] - vertice[0]));
    {
        mats[tidc] = matID;
        for (int i=0;i<3;i++) {
            const int idc = tidc*3 + i;

            if (mlength(abs(normal[i])) >= 0.00001f && GEOMETRY_BLOCK attributeUniform.haveNormal > 0) {
                verts[idc].normal = vec4(normalize(normal[i]), 1.0f);
            } else {
                verts[idc].normal = vec4(normalize(offsetnormal.xyz), 1.0f);
            }

            verts[idc].vertex = vec4(vertice[i] + offsetnormal * GEOMETRY_BLOCK geometryUniform.offset, 1.0f);
            verts[idc].color = vec4(colors[i]);
            verts[idc].texcoord = vec4(texcoord[i]);
            verts[idc].modifiers = vec4(mods[i]);
            //indics[idc] = idc;
        }
    }

    if (mode == 1) {
        tidc += 1;
        mats[tidc] = matID;
        for (int i=0;i<3;i++) {
            const int idc = tidc*3 + i;

            const int mi = (GEOMETRY_BLOCK attributeUniform.iModifiers0.w > 0 ? ms : m)[i];
            if (mlength(abs(normal[mi])) >= 0.00001f && GEOMETRY_BLOCK attributeUniform.haveNormal > 0) {
                verts[idc].normal = vec4(normalize(normal[mi]), 1.0f);
            } else {
                verts[idc].normal = vec4(normalize(offsetnormal.xyz), 1.0f);
            }

            verts[idc].vertex = vec4(vertice[mi] + offsetnormal * GEOMETRY_BLOCK geometryUniform.offset, 1.0f);
            verts[idc].color = vec4(colors[mi]);
            verts[idc].texcoord = vec4(texcoord[mi]);
            verts[idc].modifiers = vec4(mods[mi]);
            //indics[idc] = idc;
        }
    }
}
