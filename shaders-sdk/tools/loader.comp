#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
//#include "../include/uniforms.glsl"
//#include "../include/vertex.glsl"
#include "../include/STOmath.glsl"


struct MeshUniformStruct {
    int vertexAccessor;
    int normalAccessor;
    int texcoordAccessor;
    int modifierAccessor;

    mat4 transform;
    mat4 transformInv;

    int materialID;
    int isIndexed;
    int nodeCount;
    int primitiveType;

    int loadingOffset;
    int storingOffset;
    int _reserved0;
    int _reserved1;
};

struct VirtualAccessor {
    int offset;
    int stride;
    int components;
    int type; // 0 is float, 1 is uint, 2 is 16bit uint
};


#if defined(ENABLE_AMD_INSTRUCTION_SET) || defined(ENABLE_NVIDIA_INSTRUCTION_SET)
#define INDEX16 uint16_t
#define M16(m, i) (m[i])
#else
#define INDEX16 uint
#define M16(m, i) (bitfieldExtract(m[i/2], int(16*(i%2)), 16))
#endif

#ifdef ENABLE_INT16_LOADING
#define INDICE_T INDEX16
#define PICK(m, i) M16(m, i)
#else
#define INDICE_T uint
#define PICK(m, i) m[i]
#endif

LOCAL_SIZE_LAYOUT;

const int m[3] = {3, 0, 2};
const int ms[3] = {2, 1, 3};

layout ( std430, binding = 0 ) restrict buffer TCounterSSBO {int tcounter[];};
layout ( std430, binding = 1 ) readonly buffer InputVertexSSBO {float iverts[];};
layout ( std430, binding = 2 ) readonly buffer InputVertexIndicesSSBO {INDICE_T vindics[];};
layout ( std430, binding = 3 ) readonly buffer InputMaterialsSSBO {int imats[];};
layout ( std430, binding = 10 ) restrict buffer OutGeomMaterialsSSBO {int mats[];};

layout ( std430, binding = 6 ) readonly buffer IMeshUniform {MeshUniformStruct meshUniform;};
layout ( std430, binding = 7 ) readonly buffer IMeshAccessors {VirtualAccessor meshAccessors[];};


layout ( binding = 0, rgba32f) uniform image2D vertex_texture;
layout ( binding = 1, rgba32f) uniform image2D normal_texture;
layout ( binding = 2, rgba32f) uniform image2D texcoords_texture;
layout ( binding = 3, rgba32f) uniform image2D modifiers_texture;





vec4 readByAccessor(in VirtualAccessor accessors, in uint idx){
    uint stride = accessors.stride > 0 ? accessors.stride : accessors.components;
    vec4 data = vec4(
        accessors.components >= 1 ? iverts[idx * stride + accessors.offset + 0] : 0,
        accessors.components >= 2 ? iverts[idx * stride + accessors.offset + 1] : 0,
        accessors.components >= 3 ? iverts[idx * stride + accessors.offset + 2] : 0,
        accessors.components >= 4 ? iverts[idx * stride + accessors.offset + 3] : 0
    );
    return data;
}












ivec2 gatherMosaic(in ivec2 uniformCoord){
    return ivec2(uniformCoord.x * 3 + uniformCoord.y % 3, uniformCoord.y);
}

ivec2 getUniformCoord(in int indice){
    return ivec2(indice % 1023, indice / 1023);
}

// offset map for gathers
const ivec2 mit[3] = {ivec2(0,0), ivec2(1,0), ivec2(0,1)};

ivec2 mosaicIdc(in ivec2 mosaicCoord, in int idc){
    return mosaicCoord + mit[idc];
}

void main()
{
    if (gl_GlobalInvocationID.x >= meshUniform.nodeCount) return;

    const int ctriangle = int(gl_GlobalInvocationID.x);
    const int matID = /*imats[ctriangle] +*/ meshUniform.materialID;
    vec3 vertice[4] = {vec3(0.0f), vec3(0.0f), vec3(0.0f), vec3(0.0f)};
    vec3 normal[4] = {vec3(0.0f), vec3(0.0f), vec3(0.0f), vec3(0.0f)};
    vec4 texcoord[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
    vec4 colors[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
    vec4 mods[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};

    const int mode = meshUniform.primitiveType;

    const int trp = mode == 1 ? 4 : 3;
    for(int i=0;i<trp;i++){
        const uint ctri = ctriangle * trp + i;
        const uint ptri = uint(meshUniform.loadingOffset) + ctri;
        const uint vindices = meshUniform.isIndexed == 0 ? ptri : uint( PICK(vindics, ptri) );

        vec3 vpos = vec3(0.0f);
        vec4 vtex = vec4(0.0f);
        vec3 vnorm = vec3(0.0f);
        vec4 modif = vec4(0.0f);
        vec4 color = vec4(1.0f);

        { // vertex accessor are required
            vpos.xyz = readByAccessor(meshAccessors[meshUniform.vertexAccessor], vindices).xyz;
        }
        if (meshUniform.normalAccessor != -1) {
            vnorm.xyz = readByAccessor(meshAccessors[meshUniform.normalAccessor], vindices).xyz;
        }
        if (meshUniform.modifierAccessor != -1) {
            modif = readByAccessor(meshAccessors[meshUniform.modifierAccessor], vindices);
        }
        if (meshUniform.texcoordAccessor != -1) {
            vtex.xy = readByAccessor(meshAccessors[meshUniform.texcoordAccessor], vindices).xy;
        }
#ifdef INVERT_TX_Y
        vtex.y = 1.0f - vtex.y; // invert Y
#endif

        vec4 normalf  = mult4(vec4(vnorm, 0.0f), meshUniform.transformInv);
        vec4 verticef = mult4(vec4(vpos , 1.0f), meshUniform.transform);
        verticef.xyz /= verticef.w;

        vertice[i] = verticef.xyz;
        normal[i] = normalf.xyz;
        texcoord[i] = vtex;
        colors[i] = color;
        mods[i] = modif;
    }

    // adapt quads to triangles
    const int istride = mode == 1 ? 2 : 1;
    int tidc = meshUniform.storingOffset + int(gl_GlobalInvocationID.x) * istride;
    atomicAdd(tcounter[0], istride);

    vec3 offsetnormal = normalize(cross(vertice[1] - vertice[0], vertice[2] - vertice[0]));
    {
        mats[tidc] = matID;
        for (int i=0;i<3;i++) {
            ivec2 mosaicCoord = mosaicIdc(gatherMosaic(getUniformCoord(tidc)), i);
            if (mlength(abs(normal[i])) >= 0.00001f && meshUniform.normalAccessor != -1) {
                imageStore(normal_texture, mosaicCoord, vec4(normalize(normal[i]), 1.0f));
            } else {
                imageStore(normal_texture, mosaicCoord, vec4(normalize(offsetnormal.xyz), 1.0f));
            }
            imageStore(vertex_texture, mosaicCoord, vec4(vertice[i], 1.0f));
            imageStore(texcoords_texture, mosaicCoord, vec4(texcoord[i]));
            imageStore(modifiers_texture, mosaicCoord, vec4(mods[i]));
        }
    }

    if (mode == 1) {
        tidc += 1;
        mats[tidc] = matID;
        for (int i=0;i<3;i++) {
            const int mi = m[i];
            ivec2 mosaicCoord = mosaicIdc(gatherMosaic(getUniformCoord(tidc)), i);
            if (mlength(abs(normal[mi])) >= 0.00001f && meshUniform.normalAccessor != -1) {
                imageStore(normal_texture, mosaicCoord, vec4(normalize(normal[mi]), 1.0f));
            } else {
                imageStore(normal_texture, mosaicCoord, vec4(normalize(offsetnormal.xyz), 1.0f));
            }
            imageStore(vertex_texture, mosaicCoord, vec4(vertice[mi], 1.0f));
            imageStore(texcoords_texture, mosaicCoord, vec4(texcoord[mi]));
            imageStore(modifiers_texture, mosaicCoord, vec4(mods[mi]));
        }
    }
}
