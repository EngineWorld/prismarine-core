#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require
#extension GL_ARB_shader_ballot : require
//#extension GL_ARB_shader_group_vote : require

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"
#include "../experimental/ultraMath.glsl"

struct TResult {
    float dist;
    float predist;
    int triangle;
    int materialID;

    vec3 normal;
    vec3 tangent;
    vec2 uv;

    vec4 mods;
    vec4 texcoord;
    vec4 color;
};

// unoptimized at now, and can do dublicate operations
TResult loadInfo(inout TResult res) {
    int tri = res.triangle;

    VEC3 triverts[3];
    vec3 trinorms;
    vec3 texcoords;
    vec3 colors;
    vec3 mods;

    const bool valid = greaterEqualF(res.dist, 0.0f) && lessF(res.dist, INFINITY) && tri != LONGEST;
    if (bs(valid)) {

#pragma optionNV (unroll all)
        for (int x=0;x<3;x++) {
            int j = tri * 3 + x;
            triverts[x] = swiz(verts[j].vertex);
            putv3(swiz(verts[j].normal), trinorms, x);
            putv3(swiz(verts[j].texcoord), texcoords, x);
            putv3(swiz(verts[j].color), colors, x);
            putv3(swiz(verts[j].modifiers), mods, x);
        }

        vec2 uv = x(res.uv.xy);
        vec3 interpol = vec3(1.0f - uv.x - uv.y, uv.x, uv.y);

        VEC3 deltaPos1 = triverts[1] - triverts[0];
        VEC3 deltaPos2 = triverts[2] - triverts[0];
        VEC3 nor = normalize3(cross3(deltaPos1, deltaPos2));
        
        VEC3 normal = dot(trinorms, interpol); //fma(trinorms[0], vec3(1.0f - uv.x - uv.y), fma(trinorms[1], vec3(uv.x), trinorms[2] * vec3(uv.y)));
        VEC3 nNormal = normalize3(normal);
        normal = lessF(length3(normal), 0.f) ? nor : nNormal;
        normal = normal * sign(dot3(nor, normal));

        bool delta = all2(texcoords[0] == texcoords[1]) && all2(texcoords[0] == texcoords[2]);
        VEC2 deltaUV1 = delta ? (eql(0) ? 1.0f : 0.0f) : texcoords[1] - texcoords[0];
        VEC2 deltaUV2 = delta ? (eql(0) ? 0.0f : 1.0f) : texcoords[2] - texcoords[0];

        float f = 1.0f / dot(
            vec2(x(deltaUV1), -y(deltaUV1)), 
            vec2(y(deltaUV2),  x(deltaUV2))
        );
        VEC3 tang = dot(vec2(deltaPos1, -deltaPos2), vec2(y(deltaUV2), y(deltaUV1)));

        res.mods = compvec4(dot(mods, interpol)); //fma(mods[0], vec4(1.0f - uv.x - uv.y), fma(mods[1], vec4(uv.x), mods[2] * vec4(uv.y)));;
        res.normal = compvec3(normal);
        res.texcoord = compvec4(dot(texcoords, interpol));
        res.materialID = mats[tri];
        res.tangent = compvec3(normalize3(tang - normal * sign(dot3(tang, normal))));
        res.color = compvec4(dot(colors, interpol));
    }

    return res;
}

#include "../experimental/traverse.glsl"

layout ( local_size_x = WORK_SIZE * SCALARS ) in;

void main() {
    const int it = invoc(int(gl_GlobalInvocationID.x));
    //if (it >= RAY_BLOCK samplerUniform.rayCount) return;
 
    const int t = actived[it];
    Ray ray = fetchRayDirect(t);
    Hit hit = fetchHitDirect(t);
    TResult res = traverse(hit.dist, ray.origin.xyz, ray.direct.xyz, hit);

    if (
        greaterEqualF(res.dist, 0.0f) &&
        lessF(res.dist, INFINITY) &&

        (lessEqualF(res.dist, hit.dist) || GEOMETRY_BLOCK geometryUniform.clearDepth > 0) &&
        
        res.materialID >= 0 &&
        res.materialID != LONGEST
    ) {
        Hit newHit = hit;
        newHit.shaded = 0;
        newHit.dist = res.dist;
        newHit.normal.xyz = res.normal.xyz;
        newHit.triangle = res.triangle;
        newHit.materialID = res.materialID;
        newHit.texcoord = res.texcoord;
        newHit.tangent.xyz = res.tangent.xyz;
        newHit.vcolor.xyzw = res.color.xyzw;

        vec4 sysmod = newHit.vmods;
        newHit.vmods.xyzw = res.mods.xyzw;
        newHit.vmods.w = sysmod.w;

        if (mt()) storeHit(t, newHit);
    }
}
