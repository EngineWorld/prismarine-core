#version 460

#extension GL_ARB_shader_ballot : require
#extension GL_ARB_shader_group_vote : require

#define USE_WARP_OPTIMIZED

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rays.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"
#include "../experimental/ultraMath.glsl"
#include "../experimental/traverse.glsl"

struct LResult {
    vec4 normal;
    vec4 tangent;
    vec4 texcoord;
    vec4 color;
    vec4 mods;

    float dist;
    int triangle;
    int materialID;
    float predist;
    vec4 uv;
};

// unoptimized at now, and can do dublicate operations
LResult loadInfo(in TResult hitp) {
    int tri = hitp.triangle;
    vec3 triverts = vec3(0.f);
    vec3 trinorms = vec3(0.f);
    vec3 texcoords = vec3(0.f);
    vec3 colors = vec3(0.f);
    vec3 mods = vec3(0.f);
    
    LResult res;
    res.dist = hitp.dist;
    res.triangle = hitp.triangle;
    res.materialID = -1;
    res.predist = hitp.predist; // legacy
    res.uv = hitp.uv; // legacy

    res.mods = (0.f).xxxx;
    res.color = (0.f).xxxx;
    res.texcoord = (0.f).xxxx;
    res.tangent = (0.f).xxxx;
    res.normal = (0.f).xxxx;

    bool valid = greaterEqualF(hitp.dist, 0.0f) && lessF(hitp.dist, INFINITY) && tri != LONGEST;
    if (bs(valid)) {

        triverts = gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(tri)), lane4).wzx;
        trinorms = gatherMosaicCompDyn(normal_texture, gatherMosaic(getUniformCoord(tri)), lane4).wzx;
        texcoords = gatherMosaicCompDyn(texcoords_texture, gatherMosaic(getUniformCoord(tri)), lane4).wzx;
        mods = gatherMosaicCompDyn(modifiers_texture, gatherMosaic(getUniformCoord(tri)), lane4).wzx;
        colors = vec3(1.f);

        vec2 uv = x(hitp.uv.xy);
        vec3 interpol = vec3(1.0f - uv.x - uv.y, uv.x, uv.y);

        VEC3 deltaPos1 = triverts.y - triverts.x;
        VEC3 deltaPos2 = triverts.z - triverts.x;
        VEC3 nor = normalize3(cross3(deltaPos1, deltaPos2));
        
        VEC3 normal = dot(trinorms, interpol); //fma(trinorms[0], vec3(1.0f - uv.x - uv.y), fma(trinorms[1], vec3(uv.x), trinorms[2] * vec3(uv.y)));
        VEC3 nNormal = normalize3(normal);
        normal = lessF(length3(normal), 0.f) ? nor : nNormal;
        normal = normal * sign(dot3(nor, normal));

        bool delta = all2(texcoords[0] == texcoords[1]) && all2(texcoords[0] == texcoords[2]);
        VEC2 deltaUV1 = delta ? (eql(0) ? 1.0f : 0.0f) : texcoords[1] - texcoords[0];
        VEC2 deltaUV2 = delta ? (eql(0) ? 0.0f : 1.0f) : texcoords[2] - texcoords[0];

        float f = 1.0f / dot(
            vec2(x(deltaUV1), -y(deltaUV1)), 
            vec2(y(deltaUV2),  x(deltaUV2))
        );
        VEC3 tang = dot(vec2(deltaPos1, -deltaPos2), vec2(y(deltaUV2), y(deltaUV1))) * f;

        res.normal.xyz = compvec3(normal);
        res.tangent.xyz = compvec3(normalize3(tang - normal * sign(dot3(tang, normal))));
        res.texcoord = compvec4(dot(texcoords, interpol));
        res.color = compvec4(dot(colors, interpol));
        res.mods = compvec4(dot(mods, interpol));
        res.materialID = mats[tri];
    }

    return res;
}

layout ( local_size_x = WORK_SIZE * SCALARS ) in;

void main() {
    const int it = invoc(int(gl_GlobalInvocationID.x));
    const bool overflow = it >= RAY_BLOCK samplerUniform.rayCount;
    if (allInvocationsARB(overflow || !mt())) return;

    const int t = activedBuf.indc[it];
    Ray ray = fetchRayDirect(t);
    if (allInvocationsARB(ray.actived < 1 || overflow || !mt())) return;

    Hit hit = fetchHitDirect(t);
    LResult res = loadInfo(traverse(hit.dist, ray.origin[lane4], ray.direct[lane4], hit));

    if (
        greaterEqualF(res.dist, 0.0f) &&
        lessF(res.dist, INFINITY) &&

        (lessEqualF(res.dist, hit.dist) || GEOMETRY_BLOCK geometryUniform.clearDepth > 0) &&
        
        res.materialID >= 0 &&
        res.materialID != LONGEST
    ) {
        Hit newHit = hit;
        vec4 sysmod = newHit.vmods;

        newHit.normal.xyz = res.normal.xyz;
        newHit.tangent.xyz = res.tangent.xyz;
        newHit.texcoord = res.texcoord;
        newHit.vcolor = res.color;
        newHit.vmods = res.mods;
        newHit.dist = res.dist;
        newHit.triangle = res.triangle;
        newHit.materialID = res.materialID;
        newHit.shaded = 0;
        
        newHit.vmods.w = sysmod.w;

        if (mt() && !overflow) storeHit(t, newHit);
    }
}
