#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "./includes.glsl"

//LOCAL_SIZE_LAYOUT;

const int work_size = 1024;

layout ( local_size_x = work_size ) in;

void main() {
    if (gl_WorkGroupID.x > 0) return; // not supported
    const int localID = int(gl_LocalInvocationID.x);
    int n = GEOMETRY_BLOCK geometryUniform.triangleCount;
    int wcount = n > 0 ? (n - 1) / work_size + 1 : 0;

    for (int w=0;w<=wcount;w++) {
        int globalID = w * work_size + localID;
        bool inactive = globalID >= n;

        // upverse top
        int idx = Leafs[globalID].pdata.z;
        HlbvhNode nd = Nodes[idx];

        // from lower to upper
        for(int l=0;l<256;l++) {
            // get parent node
            idx = nd.pdata.z;
            nd = Nodes[idx];

            // get nodes
            HlbvhNode ln = Nodes[nd.pdata.x];
            HlbvhNode rn = Nodes[nd.pdata.y];

            // unify bounding box
            bbox bound = nd.box;
            bound.mn = min(ln.box.mn, rn.box.mn) - 0.00001f;
            bound.mx = max(ln.box.mx, rn.box.mx) + 0.00001f;
            nd.box = bound;

            // give own initiative
            if (atomicCompSwap(Flags[idx], 0, 1) == 1 && idx >= 0 && !inactive) {
                Nodes[idx] = nd;
            } else {
                inactive = true;
            }

            // sync threads for avoid conflicts
            barrier(); memoryBarrier(); groupMemoryBarrier();

            // for next work stages
            atomicExchange(Flags[idx], 0);

            // break by voting?
            if (allInvocations(inactive)) break;
        }
    }

/*
    const int globalID = int(gl_GlobalInvocationID.x);
    if (globalID < GEOMETRY_BLOCK geometryUniform.triangleCount) {
        int idx = Leafs[globalID].pdata.z;
        HlbvhNode nd = Nodes[idx];
        for(int i=0;i<256;i++) {
            idx = nd.pdata.z;
            if (idx < 0) break;

            nd = Nodes[idx];
            int tmp = atomicAdd(Flags[idx], 1);
            if (tmp == 0) {
                HlbvhNode ln = Nodes[nd.pdata.x];
                HlbvhNode rn = Nodes[nd.pdata.y];
                memoryBarrier(); groupMemoryBarrier();
                bbox bound = nd.box;
                bound.mn = min(ln.box.mn, rn.box.mn) - 0.00001f;
                bound.mx = max(ln.box.mx, rn.box.mx) + 0.00001f;
                nd.box = bound;
                Nodes[idx] = nd;
            } else {
                break;
            }

            if (idx <= 0) break;
        }
    }
*/
}
