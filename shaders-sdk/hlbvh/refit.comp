#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/STOmath.glsl"
#include "./includes.glsl"

const int work_size = 1024;
shared int aCounter;
shared int aRange[2];

layout ( local_size_x = work_size ) in;

initAtomicIncFunction(aCounter, aCounterInc, int);

void main() {
    if (gl_WorkGroupID.x > 0) return; // not supported
    const int localID = int(gl_LocalInvocationID.x);

    // init counter
    if (localID == 0) {
        aCounter = 0;
        aRange[0] = 0;
        aRange[1] = 0;
    }
    barrier(); memoryBarrier(); groupMemoryBarrier();

    { // initial nodes
        int n = GEOMETRY_BLOCK geometryUniform.triangleCount;
        int wcount = n > 0 ? (n - 1) / work_size + 1 : 0;
        for (int w=0;w<=wcount;w++) {
            int globalID = w * work_size + localID;
            if (allInvocations(globalID >= n)) { break; }

            HlbvhNode nd = Leafs[globalID];
            if (nd.pdata.z >= 0 && atomicExchange(Flags[nd.pdata.z], 1) == 0 && globalID < n) {
                atomicExchange(Actives[aCounterInc(true)], nd.pdata.z);
            }
        }
    }

    // from lower to upper
    for (int l=0;l<256;l++) {
        // synchronize, and make next work view
        barrier(); memoryBarrier(); groupMemoryBarrier();

        // copy counts
        if (localID == 0) {
            aRange[0] = aRange[1];
            aRange[1] = aCounter;
        }

        // sync count
        barrier(); memoryBarrier(); groupMemoryBarrier();
        if (aRange[1] <= aRange[0]) break; // no work, break

        // form work
        int n = aRange[1] - aRange[0];
        int wcount = n > 0 ? (n - 1) / work_size + 1 : 0;

        // unify bounding boxes on level
        for (int w=0;w<=wcount;w++) {
            int globalID = w * work_size + localID;
            if (allInvocations(globalID >= n)) { break; }

            // get current level node
            int idx = Actives[aRange[0]+globalID];
            HlbvhNode nd = Nodes[idx];

            // if parent node is not occupy
            bool validParent = nd.pdata.z >= 0 && globalID < n;
            validParent = validParent ? atomicExchange(Flags[nd.pdata.z], 1) == 0 : false;

            // defer parent nodes
            if (validParent) atomicExchange(Actives[aCounterInc( validParent )], nd.pdata.z);

            // process unifying boxes
            if (idx >= 0 && globalID <= n && nd.pdata.x != nd.pdata.y) {
                // get nodes
                HlbvhNode ln = Nodes[nd.pdata.x];
                HlbvhNode rn = Nodes[nd.pdata.y];

                // unify bounding box
                bbox bound = nd.box;
                bound.mn = min(ln.box.mn, rn.box.mn);
                bound.mx = max(ln.box.mx, rn.box.mx);
                nd.box = bound;

                // store if valid
                Nodes[idx] = nd;
            }
        }

        // sync work
        barrier(); memoryBarrier(); groupMemoryBarrier();

        // reset initiativity
        for (int w=0;w<=wcount;w++) {
            int globalID = w * work_size + localID;
            if (allInvocations(globalID >= n)) { break; }

            // get current level node
            int idx = Actives[aRange[0]+globalID];
            HlbvhNode nd = Nodes[idx];

            if (nd.pdata.z >= 0 && globalID < n) {
                atomicExchange(Flags[nd.pdata.z], 0);
            }
        }
    }
}
