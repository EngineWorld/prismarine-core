#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/STOmath.glsl"
#include "./includes.glsl"

#define LEAFIDX(i) (Range[0] + i)
#define NODEIDX(i) (clamp(i, 1, Range[0]-1))

layout ( local_size_x = 1024 ) in;

int nlz (in uint x) {
    return 31-findMSB(x);
}

int nlz (in int x) {
    return 31-findMSB(uint(x));
}

// TODO - two lane SIMD threading support
int findSplit( int first, int last, uint SIMDThread)
{
    uint firstCode = Mortoncodes[first];
    uint lastCode = Mortoncodes[last];
    if (firstCode == lastCode) {
        return (first + last) >> 1;
    }

    int commonPrefix = nlz(firstCode ^ lastCode);
    int split = first;
    int step = last - first;
    for (int i=0;i<8192;i++) {
        step = (step + 1) >> 1;
        int newSplit = split + step;
        if (newSplit < last) {
             uint splitCode = Mortoncodes[newSplit];
             int splitPrefix = nlz(firstCode ^ splitCode);
            if (splitPrefix > commonPrefix) {
                split = newSplit;
            }
        }
        if (step <= 1) break; 
    }

    return clamp(split, 0, Range[0]-2);
}

shared int lCounter;
shared int aCounter;
shared int aRange[2];

initAtomicIncFunction(lCounter, lCounterInc, int);
initAtomicIncFunction(aCounter, aCounterInc, int);

void main() {
    if (gl_WorkGroupID.x > 0) return; // not supported
    const uint threadID = uint(gl_LocalInvocationID.x);

    if (threadID == 0) {
        lCounter = 1;
        aCounter = 1;
        aRange[0] = 0;
        aRange[1] = 1;
        Actives[0] = 0;

        HlbvhNode node = Nodes[threadID];
        node.box.mn = (0.0f).xxxx;
        node.box.mx = (0.0f).xxxx;
        node.pdata.xy = ivec2(0, Range[0]-1);
        node.pdata.zw = (-1).xx;
        
        Nodes[threadID] = node;
        Flags[threadID] = 0;
    }

    int cntstdr = 0;
    for (int h=0;h<256;h++) { // every level of BVH
        // begin work on splitting
        barrier(); memoryBarrier();
        if (aRange[1] <= aRange[0]) break; // no work, break

        uint workSize = min((aRange[1] <= aRange[0]) ? 0 : (((aRange[1] - aRange[0]) - 1) / (gl_WorkGroupSize.x / 2) + 1), 8192);
        for (int i=0;i<workSize;i++) {
            uint trID = aRange[0] + ((gl_WorkGroupSize.x / 2) * i + (threadID / 2));
            uint prID = Actives[trID];
            uint chID = threadID % 2;

            if (trID < aRange[1]) {
                HlbvhNode parentNode = Nodes[prID];

                // find split
                int split = readLane(findSplit(parentNode.pdata.x, parentNode.pdata.y, chID), int((gl_SubGroupInvocationARB >> 1) << 1));
                int hid = lCounterInc(true);

                // init child node
                HlbvhNode childNode = Nodes[hid];
                childNode.box.mn = (0.0f).xxxx;
                childNode.box.mx = (0.0f).xxxx;
                childNode.pdata.zw = ivec2(prID, -1);

                // differentiation between left and right node
                childNode.pdata.xy = chID == 0 ? ivec2(parentNode.pdata.x, split+0) : ivec2(split+1, parentNode.pdata.y);

                // is leaf?
                if (childNode.pdata.x == childNode.pdata.y) {
                    uint leafID = MortoncodesIndices[childNode.pdata.x];

                    // make leafs
                    Leaf ourLeaf = Leafs[leafID];
                    ourLeaf.pdata.z = int(hid);
                    Leafs[leafID] = ourLeaf;

                    // load leaf data
                    childNode.box.mn = ourLeaf.box.mn;
                    childNode.box.mx = ourLeaf.box.mx;
                    childNode.pdata.xy = ourLeaf.pdata.xy;
                    childNode.pdata.w  = ourLeaf.pdata.w;
                } else { // add to next works
                    atomicExchange(Actives[aCounterInc(true)], hid);
                }

                Flags[hid] = 0;
                Nodes[hid] = childNode;

                // if SIMD thread is left, use left lane of parent node, else right lane
                if (chID == 0) {
                    atomicExchange(Nodes[prID].pdata.x, hid);
                } else {
                    atomicExchange(Nodes[prID].pdata.y, hid);
                }
            } else {
                break;
            }
        }

        // synchronize, and make next work view
        barrier(); memoryBarrier();
        if (threadID == 0) {
            aRange[0] = aRange[1];
            aRange[1] = aCounter;
        }
    }
}
