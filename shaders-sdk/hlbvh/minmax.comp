#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require
#extension GL_ARB_shader_ballot : require

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/STOmath.glsl"

layout ( std430, binding = 5 )  buffer MinmaxOutputSSBO {vec4 minmax[];};
layout ( local_size_x = 512 ) in;

shared bbox sdata[ 512 ];

bbox getMinMaxPrimitive(in uint idx){
    const uint tri = clamp(idx, 0u, uint(GEOMETRY_BLOCK geometryUniform.triangleCount-1));

    mat3x4 triverts = transpose(mat4x3(
        gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(tri)), 0).wzx, // x component
        gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(tri)), 1).wzx, // y component
        gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(tri)), 2).wzx, // z component
        gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(tri)), 3).wzx  // w component
    ));

    triverts[0] = mult4(triverts[0], GEOMETRY_BLOCK octreeUniform.project);
    triverts[1] = mult4(triverts[1], GEOMETRY_BLOCK octreeUniform.project);
    triverts[2] = mult4(triverts[2], GEOMETRY_BLOCK octreeUniform.project);

#ifdef ENABLE_AMD_INSTRUCTION_SET
    return bbox(
        min3(triverts[0], triverts[1], triverts[2]) - 0.00001f, 
        max3(triverts[0], triverts[1], triverts[2]) + 0.00001f
    );
#else 
    return bbox(
        min(min(triverts[0], triverts[1]), triverts[2]) - 0.00001f, 
        max(max(triverts[0], triverts[1]), triverts[2]) + 0.00001f
    );
#endif
    
}

bbox bboxunion(in bbox b1, in bbox b2) {
    return bbox(
        min(b1.mn, b2.mn),
        max(b1.mx, b2.mx)
    );
}

void main() {
    const uint tid = gl_LocalInvocationID.x;
    const uint gridSize = (gl_WorkGroupSize.x*2) * gl_NumWorkGroups.x;
    uint i = gl_WorkGroupID.x * (gl_WorkGroupSize.x*2) + tid;

    sdata[tid] = bbox(vec4( 100000.f), vec4(-100000.f));
    while (i < GEOMETRY_BLOCK geometryUniform.triangleCount) {
        sdata[tid] = bboxunion(sdata[tid], bboxunion(getMinMaxPrimitive(i), getMinMaxPrimitive(i + gl_WorkGroupSize.x)));
        i += gridSize;
    };
    barrier(); memoryBarrier();

    for (uint i=(gl_WorkGroupSize.x>>1);i>=1;i>>=1) {
        if (tid < i) {
            sdata[tid] = bboxunion(sdata[tid], sdata[tid + i]); 
        }
        if (i > gl_SubGroupSizeARB) {
            barrier(); memoryBarrier();
        }
    }

    if (tid == 0) {
        minmax[gl_WorkGroupID.x*2 + 0] = sdata[0].mn; 
        minmax[gl_WorkGroupID.x*2 + 1] = sdata[0].mx; 
    }
}
