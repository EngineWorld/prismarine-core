#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"

layout ( std430, binding = 0 ) restrict buffer MortoncodesBlock {
    MORTONTYPE Mortoncodes[];
} mortonBuf;

layout ( std430, binding = 1 ) restrict buffer IndicesBlock {
    int MortoncodesIndices[];
} mortonIdc;

layout ( std430, binding = 2 ) restrict buffer CounterBlock {
    int aabbCounter[1];
} counters;

layout ( std430, binding = 3 ) restrict buffer OutLeafBlock {
    HlbvhNode OutLeafs[];
} outLeafsBuf;

LOCAL_SIZE_LAYOUT;

uint add(inout uint mem, in uint ops){
    uint tmp = mem; mem += ops; return tmp;
}

initAtomicIncFunction(counters.aabbCounter[0], atomicIncAABB, int)

bbox calcTriBox(in mat3x4 triverts){
    bbox result;
    #ifdef ENABLE_AMD_INSTRUCTION_SET
    result.mn = min3(triverts[0], triverts[1], triverts[2]) - 0.00001f;
    result.mx = max3(triverts[0], triverts[1], triverts[2]) + 0.00001f;
#else
    result.mn = min(min(triverts[0], triverts[1]), triverts[2]) - 0.00001f;
    result.mx = max(max(triverts[0], triverts[1]), triverts[2]) + 0.00001f;
#endif
    return result;
}

const uint maxSplits = 0;

void main() {
    int t = int(gl_GlobalInvocationID.x);
    if (t >= GEOMETRY_BLOCK geometryUniform.triangleCount) return;

    vec4 mn = vec4(INFINITY);
    vec4 mx = vec4(-INFINITY);

    mat3x4 triverts = mat3x4(
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 0), 
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 1), 
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 2)
    );

    triverts[0] = mult4(triverts[0], GEOMETRY_BLOCK geometryUniform.transform);
    triverts[1] = mult4(triverts[1], GEOMETRY_BLOCK geometryUniform.transform);
    triverts[2] = mult4(triverts[2], GEOMETRY_BLOCK geometryUniform.transform);

    vec4 tcenter = (triverts[0] + triverts[1] + triverts[2]) * 0.33333333333333f;
    if (length(abs(triverts[0] - tcenter).xyz + abs(triverts[1] - tcenter).xyz + abs(triverts[2] - tcenter).xyz) < 1.e-5) return;

    uint countBox = 1;

    mat3x4 current = triverts;
    bbox bounding = calcTriBox(triverts);

    vec4 center = (current[0] + current[1] + current[2]) * 0.33333333333333f;
    int to = atomicIncAABB(true);
    mortonIdc.MortoncodesIndices[to] = int(to);

#ifdef INT64_MORTON
    mortonBuf.Mortoncodes[to] = MORTONTYPE(encodeMorton3_64(clamp(
        uvec3(floor(clamp(center.xyz, vec3(0.0f), vec3(0.99999f)) * 2097152.0f)), 
        uvec3(0), uvec3(0x1FFFFF))));
#else
    mortonBuf.Mortoncodes[to] = MORTONTYPE(encodeMorton3_64(clamp(
        uvec3(floor(clamp(center.xyz, vec3(0.0f), vec3(0.99999f)) * 1024.0f)), 
        uvec3(0), uvec3(0x3FF))));
#endif

    HlbvhNode outLeaf = outLeafsBuf.OutLeafs[to];
    outLeaf.box = bounding;
    outLeaf.pdata.xy = ivec2(to);
    outLeaf.pdata.zw = ivec2(-1, t);
    outLeafsBuf.OutLeafs[to] = outLeaf;
}
