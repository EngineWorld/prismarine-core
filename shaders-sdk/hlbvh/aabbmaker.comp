#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"

layout ( std430, binding = 0 ) restrict buffer MortoncodesBlock {
    uint Mortoncodes[];
} mortonBuf;

layout ( std430, binding = 1 ) restrict buffer IndicesBlock {
    int MortoncodesIndices[];
} mortonIdc;

layout ( std430, binding = 2 ) restrict buffer CounterBlock {
    int aabbCounter[1];
} counters;

layout ( std430, binding = 3 ) restrict buffer OutLeafBlock {
    Leaf OutLeafs[];
} outLeafsBuf;

LOCAL_SIZE_LAYOUT;

uint add(inout uint mem, in uint ops){
    uint tmp = mem; mem += ops; return tmp;
}

initAtomicIncFunction(counters.aabbCounter[0], atomicIncAABB, int)

bbox calcTriBox(in mat3x4 triverts){
    bbox result;
    #ifdef ENABLE_AMD_INSTRUCTION_SET
    result.mn = min3(triverts[0], triverts[1], triverts[2]) - 0.00001f;
    result.mx = max3(triverts[0], triverts[1], triverts[2]) + 0.00001f;
#else
    result.mn = min(min(triverts[0], triverts[1]), triverts[2]) - 0.00001f;
    result.mx = max(max(triverts[0], triverts[1]), triverts[2]) + 0.00001f;
#endif
    return result;
}

void main() {
    const int t = int(gl_GlobalInvocationID.x);
    if (t >= GEOMETRY_BLOCK geometryUniform.triangleCount) return;

    vec4 mn = vec4(INFINITY);
    vec4 mx = vec4(-INFINITY);

    mat3x4 triverts = mat3x4(
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 0), 
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 1), 
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 2)
    );

    triverts[0] = mult4(triverts[0], GEOMETRY_BLOCK geometryUniform.transform);
    triverts[1] = mult4(triverts[1], GEOMETRY_BLOCK geometryUniform.transform);
    triverts[2] = mult4(triverts[2], GEOMETRY_BLOCK geometryUniform.transform);

    vec4 tcenter = (triverts[0] + triverts[1] + triverts[2]) * 0.33333333333333f;
    if (length(abs(triverts[0] - tcenter).xyz + abs(triverts[1] - tcenter).xyz + abs(triverts[2] - tcenter).xyz) < 1.e-5) return;

    mat3x4 stack[9];
    uint split[4];
    split[0] = 0;
    stack[0] = triverts;

    const uint maxSplits = 0;
    uint countBox = 1;

    for (uint i=0;i<4;i++) {
        if (i >= countBox) break;
        
        mat3x4 current = stack[i];
        vec4 center = (current[0] + current[1] + current[2]) * 0.33333333333333f;
        if (split[i] >= maxSplits) {
            int to = atomicIncAABB(true);
            mortonIdc.MortoncodesIndices[to] = int(to);
            mortonBuf.Mortoncodes[to] = encodeMorton3_64(clamp(
                uvec3(floor(clamp(center.xyz, vec3(0.0f), vec3(0.99999f)) * 1024.0f)), 
                uvec3(0), uvec3(1023)));
            Leaf outLeaf = outLeafsBuf.OutLeafs[to];
            outLeaf.box = calcTriBox(triverts);
            outLeaf.pdata.xy = ivec2(to);
            outLeaf.pdata.zw = ivec2(-1, t);
            outLeafsBuf.OutLeafs[to] = outLeaf;
        } else {
            uint tris = add(countBox, 3);
            split[tris+0] = split[i]+1;
            stack[tris+0] = mat3x4(center, current[1], current[2]);
            split[tris+1] = split[i]+1;
            stack[tris+1] = mat3x4(current[0], center, current[2]);
            split[tris+2] = split[i]+1;
            stack[tris+2] = mat3x4(current[0], current[1], center);
        }
    }
}
