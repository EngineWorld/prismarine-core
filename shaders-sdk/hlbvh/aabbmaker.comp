#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"

layout ( std430, binding = 20 )  buffer CounterBlock {
    int aabbCounter[1];
};

layout ( std430, binding = 0 )  buffer OutLeafBlock {
    Leaf OutLeafs[];
};

layout ( std430, binding = 1 )  buffer MortoncodesBlock {
    uint Mortoncodes[];
};

layout ( std430, binding = 2 )  buffer IndicesBlock {
    int MortoncodesIndices[];
};

LOCAL_SIZE_LAYOUT;

uint add(inout uint mem, in uint ops){
    const uint tmp = mem; mem += ops; return tmp;
}

void main() {
    const int t = int(gl_GlobalInvocationID.x);
    if (t >= GEOMETRY_BLOCK geometryUniform.triangleCount) return;

    vec4 mn = vec4(INFINITY);
    vec4 mx = vec4(-INFINITY);
    vec3 triverts[3], tp[3];
    
    const int tri3 = t * 3;
    for (int x=0;x<3;x++) {
        const int j = tri3 + x;
        const vec4 nps = mult4(vec4(verts[j].vertex.xyz, 1.0f), GEOMETRY_BLOCK octreeUniform.project);
        triverts[x] = nps.xyz / nps.w;
    }

    const vec3 tcenter = (triverts[0] + triverts[1] + triverts[2]) * 0.33333333333333f;
    for (int i=0;i<3;i++) {
        tp[i] = triverts[i] - tcenter;
    }
    if (length(abs(tp[0]) + abs(tp[1]) + abs(tp[2])) < 1.e-5) return;

#ifdef ENABLE_AMD_INSTRUCTION_SET
    mn.xyz = min3(triverts[0], triverts[1], triverts[2]);
    mx.xyz = max3(triverts[0], triverts[1], triverts[2]);
#else
    mn.xyz = min(min(triverts[0], triverts[1]), triverts[2]);
    mx.xyz = max(max(triverts[0], triverts[1]), triverts[2]);
#endif

/*
    const int to = atomicAdd(aabbCounter[0], 1);
    const bbox current = bbox(mn, mx);
    const vec3 center = (current.mn.xyz + current.mx.xyz) * 0.5f;

    MortoncodesIndices[to] = int(to);
    Mortoncodes[to] = encodeMorton3_64(clamp(
        uvec3(floor(clamp(center, vec3(0.00001f), vec3(0.99999f)) * 1024.0f)), 
        uvec3(0), uvec3(1023)));

    Leaf outLeaf = OutLeafs[to];
    outLeaf.box.mn = current.mn - 0.0001f;
    outLeaf.box.mx = current.mx + 0.0001f;
    outLeaf.pdata.zw = ivec2(-1, t);
    outLeaf.pdata.xy = ivec2(to);
    OutLeafs[to] = outLeaf;
*/

    // Starting from
    bbox stack[4];
    uint split[4];
    
    split[0] = 0;
    stack[0] = bbox(mn, mx);

    const uint maxSplits = 1;
    uint countBox = 1;

    for (uint i=0;i<countBox;i++) {
        const bbox current = stack[i];
        const vec3 center = (current.mn.xyz + current.mx.xyz) * 0.5f;

        if (split[i] >= maxSplits) {
            const int to = atomicAdd(aabbCounter[0], 1);

            MortoncodesIndices[to] = int(to);
            Mortoncodes[to] = encodeMorton3_64(clamp(
                uvec3(floor(clamp(center, vec3(0.00001f), vec3(0.99999f)) * 1024.0f)), 
                uvec3(0), uvec3(1023)));

            Leaf outLeaf = OutLeafs[to];
            outLeaf.box.mn = current.mn - 0.0001f;
            outLeaf.box.mx = current.mx + 0.0001f;
            outLeaf.pdata.xy = ivec2(to);
            outLeaf.pdata.zw = ivec2(-1, t);
            OutLeafs[to] = outLeaf;
        } else {
            const vec4 diff = current.mx - current.mn;
            const uint halfBoxLeft  = add(countBox, 2);
            const uint halfBoxRight = halfBoxLeft+1;
            const float longest = max(max(diff.x, diff.y), diff.z);

            bbox leftBox  = current;
            bbox rightBox = current;
            if (equalF(longest, diff.x)) {
                rightBox.mn.x = leftBox.mx.x = center.x;
            } else 
            if (equalF(longest, diff.y)) {
                rightBox.mn.y = leftBox.mx.y = center.y;
            } else {
                rightBox.mn.z = leftBox.mx.z = center.z;
            }
            
            split[halfBoxLeft] = split[i]+1;
            stack[halfBoxLeft] = leftBox;
            split[halfBoxRight] = split[i]+1;
            stack[halfBoxRight] = rightBox;
        }
    }
}
