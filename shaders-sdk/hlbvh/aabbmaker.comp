#version 450

#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shading_language_420pack : require

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/vertex.glsl"
#include "../include/morton.glsl"
#include "../include/STOmath.glsl"

layout ( std430, binding = 20 ) buffer CounterBlock {
    int aabbCounter[1];
} counters;

layout ( std430, binding = 0 )  buffer OutLeafBlock {
    Leaf OutLeafs[];
} outLeafsBuf;

layout ( std430, binding = 1 )  buffer MortoncodesBlock {
    uint Mortoncodes[];
} mortonBuf;

layout ( std430, binding = 2 )  buffer IndicesBlock {
    int MortoncodesIndices[];
} mortonIdc;

LOCAL_SIZE_LAYOUT;

uint add(inout uint mem, in uint ops){
    uint tmp = mem; mem += ops; return tmp;
}

void main() {
    const int t = int(gl_GlobalInvocationID.x);
    if (t >= GEOMETRY_BLOCK geometryUniform.triangleCount) return;

    vec4 mn = vec4(INFINITY);
    vec4 mx = vec4(-INFINITY);

    //mat3x4 triverts = transpose(mat4x3(
    //    gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(t)), 0).wzx, // x component
    //    gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(t)), 1).wzx, // y component
    //    gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(t)), 2).wzx, // z component
    //    gatherMosaicCompDyn(vertex_texture, gatherMosaic(getUniformCoord(t)), 3).wzx  // w component
    //));

    mat3x4 triverts = mat3x4(
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 0), 
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 1), 
        fetchMosaic(vertex_texture, gatherMosaic(getUniformCoord(t)), 2)
    );

    triverts[0] = mult4(triverts[0], GEOMETRY_BLOCK octreeUniform.project);
    triverts[1] = mult4(triverts[1], GEOMETRY_BLOCK octreeUniform.project);
    triverts[2] = mult4(triverts[2], GEOMETRY_BLOCK octreeUniform.project);

    vec4 tcenter = (triverts[0] + triverts[1] + triverts[2]) * 0.33333333333333f;
    if (length(abs(triverts[0] - tcenter).xyz + abs(triverts[1] - tcenter).xyz + abs(triverts[2] - tcenter).xyz) < 1.e-5) return;

#ifdef ENABLE_AMD_INSTRUCTION_SET
    mn = min3(triverts[0], triverts[1], triverts[2]);
    mx = max3(triverts[0], triverts[1], triverts[2]);
#else
    mn = min(min(triverts[0], triverts[1]), triverts[2]);
    mx = max(max(triverts[0], triverts[1]), triverts[2]);
#endif

    // Starting from
    bbox stack[4];
    uint split[4];
    
    split[0] = 0;
    stack[0] = bbox(mn, mx);

    const uint maxSplits = 0;
    uint countBox = 1;
    uint iteration = 0;

    for (uint i=0;i<countBox;i++) {
        if ((iteration++) >= 10) break;
        
        bbox current = stack[i];
        vec4 center = (current.mn + current.mx) * 0.5f;

        if (split[i] >= maxSplits) {
            int to = atomicAdd(counters.aabbCounter[0], 1);

            mortonIdc.MortoncodesIndices[to] = int(to);
            mortonBuf.Mortoncodes[to] = encodeMorton3_64(clamp(
                uvec3(floor(clamp(center.xyz, vec3(0.00001f), vec3(0.99999f)) * 1024.0f)), 
                uvec3(0), uvec3(1023)));

            Leaf outLeaf = outLeafsBuf.OutLeafs[to];
            outLeaf.box.mn = current.mn - 0.0001f;
            outLeaf.box.mx = current.mx + 0.0001f;
            outLeaf.pdata.xy = ivec2(to);
            outLeaf.pdata.zw = ivec2(-1, t);
            outLeafsBuf.OutLeafs[to] = outLeaf;
        } else {
             vec4 diff = current.mx - current.mn;
             uint halfBoxLeft  = add(countBox, 2);
             uint halfBoxRight = halfBoxLeft+1;
             float longest = max(max(diff.x, diff.y), diff.z);

            bbox leftBox  = current;
            bbox rightBox = current;
            if (equalF(longest, diff.x)) {
                rightBox.mn.x = leftBox.mx.x = center.x;
            } else 
            if (equalF(longest, diff.y)) {
                rightBox.mn.y = leftBox.mx.y = center.y;
            } else {
                rightBox.mn.z = leftBox.mx.z = center.z;
            }
            
            split[halfBoxLeft] = split[i]+1;
            stack[halfBoxLeft] = leftBox;
            split[halfBoxRight] = split[i]+1;
            stack[halfBoxRight] = rightBox;
        }
    }
}
