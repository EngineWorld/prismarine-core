#version 460 core

//#define USE_SIMPLIFIED_MODEL
#define USE_NOISE_LESS_BRDF

#include "../include/constants.glsl"

#ifdef USE_BINDLESS
#extension GL_ARB_bindless_texture : require
#endif

#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"
#include "../include/shadinglib.glsl"
#include "../public/environment.glsl"

vec4 composite(in vec4 src, in vec4 dst){
    float oa = src.a + dst.a * (1.0f - src.a);
    return clamp(vec4((src.rgb * src.a + dst.rgb * dst.a * (1.0f - src.a)) / max(oa, 0.00001f), oa), vec4(0.0f), vec4(1.0f));
}




struct SurfaceUnpacked {
    highp vec4 uvt; // UV, distance, triangle
    highp vec4 normalHeight; // normal with height mapping, will already interpolated with geometry
    highp vec4 texcoord;
    highp vec4 metallicRoughness;

    // color parameters
    highp vec4 emission;
    highp vec4 albedo;
};



LOCAL_SIZE_LAYOUT;

void main() {
    int it = int(gl_GlobalInvocationID.x);
    bool overflow = it >= RAY_BLOCK samplerUniform.rayCount;
    bool skipping = overflow;

    int t = activedBuf.indc[it];
    globalInvocationSMP = it;
    RayRework ray = rayBuf.nodes[t];

    int layers = 1; // support only one layer
    int currentLayer = 0;

    SurfaceUnpacked compositedHit[1];
    if (ray.hit == -1) {
        compositedHit[0].uvt = vec4(vec2(0.f), INFINITY, intBitsToFloat(-1));
    } else {
        HitRework firstHit = hitBuf.nodes[ray.hit];
        compositedHit[0].uvt = firstHit.uvt;
        compositedHit[0].albedo = firstHit.albedo;
        compositedHit[0].emission = firstHit.emission;
        compositedHit[0].metallicRoughness.yz = unpackHalf2x16(firstHit.metallicRoughness.x);
        compositedHit[0].normalHeight = firstHit.normalHeight;
    }

    // layers composition
    int searchLayer = 0;
    int hitID = hitBuf.nodes[ray.hit].next;
    for (int i=0;i<8;i++) {
        if (hitID == -1) break;
        HitRework hit = hitBuf.nodes[hitID];
        if (!equalF(compositedHit[searchLayer].uvt.z, hit.uvt.z)) {
            searchLayer = layers++;
            break; // unsupported
        }

        // composite decals
        compositedHit[searchLayer].uvt = hit.uvt;
        compositedHit[searchLayer].albedo = composite(compositedHit[searchLayer].albedo, hit.albedo);
        compositedHit[searchLayer].normalHeight = mix(compositedHit[searchLayer].normalHeight, hit.normalHeight, hit.albedo.w);
        compositedHit[searchLayer].metallicRoughness.yz = mix(compositedHit[searchLayer].metallicRoughness.yz, unpackHalf2x16(hit.metallicRoughness.x), hit.albedo.w);
        compositedHit[searchLayer].emission = mix(compositedHit[searchLayer].emission, hit.emission, hit.albedo.w);

        // already filled layer
        if (compositedHit[searchLayer].albedo.a > 0.99999f) continue;

        hitID = hit.next;
    }


    // apply physical lights
    int lc = -1;
    if (RayDL(ray) > 0 && (RayType(ray) == 1 || RayType(ray) == 2) && !skipping) {
        for (int i=0;i<min(RAY_BLOCK materialUniform.lightcount, 16);i++) {
            float md = 1.0f;
            float dt = intersectSphere(ray.origin.xyz, ray.direct.xyz, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            if (lessF(dt, INFINITY) && lessEqualF(t, compositedHit[currentLayer].uvt.z)) {
                lc = i;
            }
        }
    }

    // shade light
    if (lc >= 0 && (RayTargetLight(ray) == lc || RayType(ray) != 2)){
        ray.final.xyz = ray.color.xyz * getLightColor(lc);
        ray.color.xyz *= 0.0f;
        RayActived(ray, 0);
        skipping = true;
    }


    // apply background
    {
        vec4 color = vec4(0.0f);
        EnvironmentShader(color, ray);

        if (greaterEqualF(compositedHit[currentLayer].uvt.z, INFINITY) && RayType(ray) != 2 && !skipping) {
            ray.final.xyz = ray.color.xyz * color.xyz;
            ray.color.xyz *= 0.0f;
            RayActived(ray, 0);
            skipping = true;
        }
    }

    // resolve and valiate ray
    ray.direct.xyz = normalize(ray.direct.xyz);
    ray.origin.xyz = ray.origin.xyz + ray.direct.xyz * compositedHit[currentLayer].uvt.z;

    // not shadeable skipping
    if (RayActived(ray) < 1 || ray.hit == -1) {
        skipping = true;
    }

    // get normals
    vec3 surfacenormal = compositedHit[currentLayer].normalHeight.xyz;
    vec3 normal = faceforward(surfacenormal, ray.direct.xyz, surfacenormal);

    // get texture composition data
    vec4 tx = compositedHit[currentLayer].albedo;
    vec4 emi = compositedHit[currentLayer].emission;
    float refly = compositedHit[currentLayer].metallicRoughness.y; // roughness
    vec3 dielectric = vec3(clamp(0.04f + pow(1.0f - abs(dot(ray.direct.xyz, normal)), 5.0f), 0.0f, 1.0f));
    vec3 sc = mix(dielectric, tx.xyz, sqrt(compositedHit[currentLayer].metallicRoughness.z));

    // we coming to PBR model
    float emis = mlength(emi.xyz);
    float spca = clamp(mlength(sc.xyz), 0.0f, 1.0f);
    float prom = 1.0f - tx.a;

    // create rays
    RayRework diffuseRay = ray;
    diffuseRay.final.xyz *= 0.0f;

    RayRework reflectionRay = ray;
    reflectionRay.final.xyz *= 0.0f;

    RayRework emissiveRay = ray;
    emissiveRay.final.xyz *= 0.0f;
    
    if (!skipping) ray.final.xyz *= 0.f;

    if (RayActived(ray) > 0 && !skipping) {
        ray.final.xyz *= 0.0f;

#ifdef USE_SIMPLIFIED_MODEL
        diffuseRay = emissive(emissiveRay, mix(vec3(0.1f), tx.xyz, max(dot( normalize(lightCenter(0).xyz - ray.origin.xyz) , normal), 0.0f)), normal);
        diffuseRay.color.xyz *= (1.0f - prom);
        diffuseRay.final.xyz *= (1.0f - prom);
        reflectionRay = reflection(reflectionRay, clamp(sc.xyz / spca, 0.0f, 1.0f), normal, 0.f);
#else
        diffuseRay = diffuse(diffuseRay, tx.xyz, normal);
        diffuseRay.color.xyz *= (1.0f - prom);
        diffuseRay.color.xyz *= clamp(1.0f - emis, 0.0f, 1.0f);
        reflectionRay = reflection(reflectionRay, clamp(sc.xyz / spca, 0.0f, 1.0f), normal, refly);
#endif

        reflectionRay.color.xyz *= (1.0f - prom);
        
        emissiveRay = emissive(emissiveRay, emi.xyz, normal);
        emissiveRay.color.xyz *= (1.0f - prom);
        emissiveRay.final.xyz *= (1.0f - prom);

        ray = promised(ray, normal);
        ray.color.xyz *= prom;
    } else {
        reflectionRay.color.xyz *= 0.0f;
        emissiveRay.color.xyz *= 0.0f;
        diffuseRay.color.xyz *= 0.0f;
        diffuseRay.final.xyz *= 0.0f;
    }

    // emit rays
    if (!overflow && !skipping) {

#ifdef USE_SIMPLIFIED_MODEL
        mixed(diffuseRay.final.xyz, reflectionRay.color.xyz, clamp(spca, 0.0f, 1.0f));
        emitRay(reflectionRay, normal, 1.0f);
        emitRay(diffuseRay, normal, 1.0f);
        emitRay(emissiveRay, normal, clamp(emis, 0.0f, 1.0f));
#else
#ifdef USE_NOISE_LESS_BRDF
        mixed(diffuseRay.color.xyz, reflectionRay.color.xyz, clamp(spca, 0.0f, 1.0f));
#else 
        mixed(diffuseRay.color.xyz, reflectionRay.color.xyz, clamp(float(random() < spca), 0.0f, 1.0f));
#endif
        emitRay(reflectionRay, normal, 1.0f);
        applyLight(directLight(0, diffuseRay, vec3(1.0f), normal), diffuseRay, surfacenormal); // push shadow
        emitRay(diffuseRay, normal, 1.0f);
        emitRay(emissiveRay, normal, clamp(emis, 0.0f, 1.0f));
#endif

        
    }

    // re-store current
    if (!overflow) {
        storeRay(t, ray);
    }
}
