#version 460 core

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "./includes.glsl"

layout ( local_size_x = 1024 ) in;

int nlz (in uint64_t x) {
    //return 63-findMSB(x);
    uvec2 pair = U2P(x);
    int msbNear = findMSB(pair.y);
    int nlzFinal = (msbNear >= 0) ? msbNear : (32 + findMSB(pair.x));
    return 63-nlzFinal;
}

int nlz (in uint x) {
    return 31-findMSB(x);
}

int nlz (in int x) {
    return 31-findMSB(uint(x));
}


int delta( in uint i1, in uint i2) {
    uint left = min(i1, i2);
    uint right = max(i1, i2);
    int dlt = -1;
    if (left >= 0 && right < Range[0]) {
        MORTONTYPE leftcode = Mortoncodes[left];
        MORTONTYPE rightcode = Mortoncodes[right];
        dlt = leftcode != rightcode ? nlz(leftcode ^ rightcode) : (64 + nlz(left ^ right));
    }
    return dlt;
}

ivec2 findSpan(in int idx){
    int d = sign(delta(idx, idx+1) - delta(idx, idx-1));
    int delta_min = delta(idx, idx-d);
    int lmax = 2;
    while (delta(idx,idx + lmax * d) > delta_min) lmax *= 2;

    int l = 0;
    int t = lmax;
    do {
        t >>= 1;
        if (delta(idx, idx + (l + t)*d) > delta_min) {
            l = l + t;
        }
    }
    while (t > 1);

    ivec2 span;
    span.x = min(idx, idx + l*d);
    span.y = max(idx, idx + l*d);
    return clamp(span, ivec2(0), ivec2(Range[0]-1));
}

int findSplit( int first, int last, uint SIMDThread) {
    int left = first;
    int right = last;
    int numidentical = delta(left, right);
    do {
        int newsplit = (right + left) >> 1;
        if (delta(left, newsplit) > numidentical) {
            left = newsplit; 
        } else {
            right = newsplit;
        }
    }
    while (right > left + 1);
    return clamp(left, first, last-1);
}


int leafIdx(in int idx){
    return (Range[0]-1) + idx;
}

uint leafIdx(in uint idx){
    return (Range[0]-1) + idx;
}

//int nodeIdx(int idx){
//    return idx;
//}


shared int cCounter;
shared int lCounter;
shared int aCounter;
shared int aRange[2];

initAtomicIncFunction(lCounter, lCounterInc, int);
initAtomicIncFunction(aCounter, aCounterInc, int);
initAtomicIncFunction(cCounter, cCounterInc, int);

void main() {

/*
    uint gid = uint(gl_GlobalInvocationID.x);
    if (gid < Range[0]) {
        uint cid = leafIdx(gid);
        Nodes[cid].box.mn = ( 0.0f).xxxx;
        Nodes[cid].box.mx = (-0.0f).xxxx;
        Nodes[cid].pdata.xy = ivec2(gid.xx);
        Nodes[cid].pdata.w = -1;
        atomicExchange(Flags[cid], 0);
        atomicExchange(LeafIndices[gid], int(cid));
        atomicExchange(Actives[gid], -1);
        atomicExchange(Actives[leafIdx(gid)], -1);
    }

    // if first node, set parent -1
    if (gid == 0) {
        atomicExchange(Nodes[gid].pdata.z, -1);
    }

    if (gid < Range[0]-1) {
        ivec2 span = findSpan(int(gid));
        int split = findSplit(span.x, span.y, 0);

        int leftIdx = split+0;
        int rightIdx = split+1;

        int leftIdxI  = leftIdx  == span.x ? leafIdx(leftIdx) : leftIdx;
        int rightIdxI = rightIdx == span.y ? leafIdx(rightIdx) : rightIdx;

        // link nodes
        Nodes[gid].pdata.xy = ivec2(leftIdxI, rightIdxI);
        Nodes[gid].pdata.w = -1;
        Nodes[gid].box.mn = ( 0.0f).xxxx;
        Nodes[gid].box.mx = (-0.0f).xxxx;
        atomicExchange(Flags[gid], 0);
        atomicExchange(Nodes[leftIdxI].pdata.z, int(gid));
        atomicExchange(Nodes[rightIdxI].pdata.z, int(gid));
    }
*/

    uint threadID = uint(gl_LocalInvocationID.x);

    // set leaf indices to initial
    uint workSize = min((Range[0] <= 0) ? 0 : ((Range[0] - 1) / int(gl_WorkGroupSize.x) + 1), 8192);
    for (int i=0;i<workSize;i++) {
        int trID = int(gl_WorkGroupSize.x) * i + int(threadID);
        atomicExchange(LeafIndices[trID], -1);
        atomicExchange(Actives[trID], -1);
    }

    if (threadID == 0) {
        lCounter = 0, aCounter = 0, cCounter = 0;
        aRange[0] = 0, aRange[1] = 0;

        int hid = lCounterInc(true);
        atomicExchange(Actives[aCounterInc(true)], hid);

        HlbvhNode node = Nodes[hid];
        node.box.mn = (0.0f).xxxx;
        node.box.mx = (0.0f).xxxx;
        node.pdata.xy = ivec2(0, Range[0]-1);
        node.pdata.zw = (-1).xx;
        
        Nodes[hid] = node;
        Flags[hid] = 0;
    }

    // construct BVH
    for (int h=0;h<256;h++) { // every level of BVH

        // synchronize, and make next work view
        memoryBarrier(); barrier(); 
        if (threadID == 0) {
            aRange[0] = aRange[1];
            aRange[1] = aCounter;
        }

        // begin work on splitting
        memoryBarrier(); barrier(); 
        if (aRange[1] <= aRange[0]) break; // no work, break

        uint workSize = min((aRange[1] <= aRange[0]) ? 0 : (((aRange[1] - aRange[0]) - 1) / (int(gl_WorkGroupSize.x) / 2) + 1), 8192);
        for (int i=0;i<workSize;i++) {
            int trID = aRange[0] + ((int(gl_WorkGroupSize.x) / 2) * i + (int(threadID) / 2));
            if (allInvocations(trID >= aRange[1])) break;

            if (trID < aRange[1]) {
                int chID = int(threadID) % 2;
                int wsID = int((int(gl_LocalInvocationID.x % gl_SubGroupSizeARB) >> 1) << 1);
                int prID = readLane(chID == 0 ? atomicExchange(Actives[trID], -1) : -1, wsID);
                HlbvhNode parentNode = Nodes[prID];

                if (parentNode.pdata.x != parentNode.pdata.y && prID != -1) {
                    // find split
                    int split = readLane(findSplit(parentNode.pdata.x, parentNode.pdata.y, chID), wsID);
                    int hid = lCounterInc(true);

                    // init child node
                    HlbvhNode childNode = Nodes[hid];
                    childNode.box.mn = (0.0f).xxxx;
                    childNode.box.mx = (0.0f).xxxx;
                    childNode.pdata.zw = ivec2(prID, -1);

                    // differentiation between left and right node
                    childNode.pdata.xy = chID == 0 ? ivec2(parentNode.pdata.x, split+0) : ivec2(split+1, parentNode.pdata.y);

                    // is leaf?
                    //if (childNode.pdata.x == childNode.pdata.y) {
                    bool isLeaf = (childNode.pdata.y - childNode.pdata.x) < 1;
                    if (isLeaf) {
                        atomicExchange(LeafIndices[cCounterInc(true)], hid);
                    } else { // add to next works
                        atomicExchange(Actives[aCounterInc(true)], hid);
                    }

                    Flags[hid] = 0;
                    Nodes[hid] = childNode;

                    // if SIMD thread is left, use left lane of parent node, else right lane
                    if (chID == 0) {
                        atomicExchange(Nodes[prID].pdata.x, hid);
                    } else {
                        atomicExchange(Nodes[prID].pdata.y, hid);
                    }
                }
            }
        }
    }

}
