#version 460 core

// Readme license https://github.com/AwokenGraphics/prismarine-core/blob/master/LICENSE.md

#define _ORDERED_ACCESS

#include "../include/constants.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "./includes.glsl"

const int work_size = 1024;
layout ( local_size_x = work_size ) in;

int nlz (in uint64_t x) {
    uvec2 pair = U2P(x);
    int msbNear = findMSB(pair.y);
    int nlzFinal = (msbNear >= 0) ? msbNear : (32 + findMSB(pair.x));
    return 63-nlzFinal;
}

int nlz (in uint x) {
    return 31-findMSB(x);
}

int nlz (in int x) {
    return 31-findMSB(uint(x));
}

int findSplit( int first, int last, uint SIMDThread) {
    MORTONTYPE firstCode = Mortoncodes[first];
    MORTONTYPE lastCode = Mortoncodes[last];

    int split = (first + last) >> 1;
    if (firstCode != lastCode) {
        split = first;
        int commonPrefix = nlz(firstCode ^ lastCode);
        int step = last - first;
        for (int i=0;i<8192;i++) {
            step = (step + 1) >> 1;
            int newSplit = split + step;
            if (newSplit < last) {
                MORTONTYPE splitCode = Mortoncodes[newSplit];
                int splitPrefix = nlz(firstCode ^ splitCode);
                if (splitPrefix > commonPrefix) {
                    split = newSplit;
                }
            }
            if (step <= 1) break; 
        }
    }
    return clamp(split, first, last-1);
}

layout ( std430, binding = 8 ) restrict buffer BuildCounters {
    int cCounter;
    int lCounter;
    int aCounter;
    int bvhLevel;
    int aRange[2];
};

initAtomicIncFunction(lCounter, lCounterInc, int);
initAtomicIncFunction(aCounter, aCounterInc, int);
initAtomicIncFunction(cCounter, cCounterInc, int);

void main() {
    uint threadID = uint(gl_LocalInvocationID.x);
    int workID = int(gl_WorkGroupID.x);
    int WS = int(gl_WorkGroupSize.x);
    int hWS = int(gl_WorkGroupSize.x) / 2;

    // begin work on splitting
    uint workSize = min((aRange[1] <= aRange[0]) ? 0 : (((aRange[1] - aRange[0]) - 1) / hWS + 1), 8192);
    for (int i=0;i<workSize;i+=int(gl_NumWorkGroups)) {
        int trID = aRange[0] + hWS * (i+workID) + int(threadID) / 2;
        if (trID < aRange[1]) {
            int chID = int(LANE_IDX)&1;
            int wsID = (int(LANE_IDX) >> 1) << 1;
            int prID = readLane(chID == 0 ? atomicExchange(Actives[trID], -1) : -1, wsID);
            HlbvhNode parentNode = Nodes[prID];

            if (parentNode.branch[0] != parentNode.branch[1] && prID != -1) {
                // find split
                int split = readLane(findSplit(parentNode.branch[0], parentNode.branch[1], chID), wsID);
                int hid = lCounterInc(true);

                // init child node
                HlbvhNode childNode = Nodes[hid];
                childNode.box.mn = ( 100000.0f).xxxx;
                childNode.box.mx = (-100000.0f).xxxx;
                childNode.pdata.xy = ivec2(prID, -1);

                // differentiation between left and right node
                childNode.branch = chID == 0 ? int[2](parentNode.branch[0], split+0) : int[2](split+1, parentNode.branch[1]);

                // is leaf?
                bool isLeaf = (childNode.branch[1] - childNode.branch[0]) < 1;
                if (isLeaf) {
                    atomicExchange(LeafIndices[cCounterInc(true)], hid);
                } else { // add to next works
                    atomicExchange(Actives[aCounterInc(true)], hid);
                }

                Flags[hid] = 0;
                Nodes[hid] = childNode;

                // if SIMD thread is left, use left lane of parent node, else right lane
                Nodes[prID].branch[chID] = hid;
            }
        }
    }

}
