#version 460 core
#include "./includes.glsl"

//layout (local_size_x = WARP_SIZE, local_size_y = WORK_SIZE) in;
layout (local_size_x = BLOCK_SIZE) in;

#define LOCAL_SORT_SIZE (WORK_SIZE*RADICES)

shared UVEC64_WARP localSort64[BLOCK_SIZE];
shared uint localSort[LOCAL_SORT_SIZE];
shared uint localSortVal[BLOCK_SIZE];
shared uint localHistogramToCarry[RADICES];
shared uint localHistogram[RADICES];
shared uint warpPScan[WORK_SIZE];
shared uint psums[WORK_SIZE];
shared uint totals[WORK_SIZE];
shared uint bcount;

// prefix scan for WARP vector
uint prefix_scan(inout UVEC_WARP v){
    BVEC_WARP btf = (v == 1);
    UVEC_BALLOT_WARP bits = ballotHW(btf);
    UVEC_WARP sum = bitCount64(bits);
    v = bitCount64(bits & genLtMask());
    return sum;
}

// WARP version of prefix_sum
uint prefix_sum(in uint data, inout uint total_sum) {
    UVEC_WARP rsort = data;
    for (uint i = 1; i < WORK_SIZE_RT; i <<= 1) {
        rsort += READ_LANE(rsort, LANE_IDX - i) * uint(LANE_IDX < WORK_SIZE_RT);
    }
    total_sum = READ_LANE(rsort, WORK_SIZE_RT-1);
    UVEC_WARP result = READ_LANE(rsort, LANE_IDX - 1) * uint(LANE_IDX < WORK_SIZE_RT);
    return result;
}

void sortBits(inout UVEC64_WARP sort, inout uint sortVal){
    UVEC_WARP addr = LT_IDX;
    for (int i=0;i<BITS_PER_PASS;i++) {
        BVEC_WARP cmp = BFE(sort, int(Shift*BITS_PER_PASS) + i, 1) == 0;
        UVEC_WARP warpKey = UVEC_WARP(cmp);

        // prefix scan for WARP vector
        warpPScan[LC_IDX] = prefix_scan(warpKey); // cache by WARP ID
        
        // use LANE_IDX as LC_IDX, so we did caching, WARP size should less or equal than WORK_SIZE
        memoryBarrier(); barrier();
        if (LC_IDX == 0) {
            uint warpTotal = 0;
            uint prefixSum = prefix_sum(warpPScan[LANE_IDX], warpTotal);
            if (LANE_IDX < WORK_SIZE_RT) {
                psums [LANE_IDX] = prefixSum;
                totals[LANE_IDX] = warpTotal;
            }
        }
        memoryBarrier(); barrier();
        
        // use generalized local indexing (incl. warps)
        warpKey += psums[LC_IDX];

        UVEC_WARP destAddr = cmp ? warpKey : (addr - warpKey + totals[LC_IDX]);
        localSort64 [destAddr] = sort;
        localSortVal[destAddr] = sortVal;
        memoryBarrier(); barrier();

        sort    = localSort64 [addr];
        sortVal = localSortVal[addr];
        memoryBarrier(); barrier();
    }
}


void prefix_scan(){
    UVEC_WARP localIdx = LT_IDX;

    memoryBarrier(); barrier();
    uint tmp = localIdx >= 1 && localIdx < RADICES ? localHistogram[localIdx-1] : 0;
    memoryBarrier(); barrier();
    if (localIdx < RADICES) localHistogram[localIdx] = tmp;

    // reduction prefix-scan
    memoryBarrier(); barrier();
    for (int i=1;i<RADICES;i<<=1) {
        uint idx = localIdx;
        uint off = idx >= i && idx < RADICES ? localHistogram[idx-i] : 0;
        uint hst = localHistogram[idx];
        memoryBarrier(); barrier();
        if (idx < RADICES) localHistogram[idx] = off + hst;
        memoryBarrier(); barrier();
    }
}


void main(){
    blocks_info blocks = get_blocks_info(NumKeys, WG_IDX);
    UVEC_WARP localIdx = LT_IDX;
    if (localIdx < RADICES) localHistogram[localIdx] = 0;
    memoryBarrier(); barrier(); 

    // histograms
    UVEC_WARP addr = blocks.offset + localIdx;
    for (int i=0;i<1024;i++) {
        if (i >= blocks.count) break;

        BVEC_WARP validAddress = addr < NumKeys;
        UVEC64_WARP data = UVEC64_WARP(KeyIn[addr]);
        UVEC_WARP k = UVEC_WARP(BFE(data, int(Shift*BITS_PER_PASS), BITS_PER_PASS));
        UVEC_WARP key = k;

        // smaller version (generalized)
        if (validAddress) atomicAdd(localHistogram[key], UVEC_WARP(validAddress));
        addr += BLOCK_SIZE_RT;
    }
    
    prefix_scan();

    { // permute
        if (localIdx < RADICES) localHistogramToCarry[localIdx] = localHistogram[localIdx];

        addr = blocks.offset + localIdx;
        if (localIdx == 0) bcount = blocks.count;
        memoryBarrier(); barrier();

        for ( int i_block=0; i_block < 1024 ; i_block++ ) {
            if (i_block >= bcount) break;

            BVEC_WARP validAddress = addr < NumKeys;
            UVEC64_WARP data       = validAddress ? UVEC64_WARP(KeyIn[addr]) : 0xFFFFFFFFFFFFFFFFul;
              UVEC_WARP dataValue  = validAddress ? ValueIn[addr] : 0u;
            sortBits(data, dataValue); // sort inside WARP

            UVEC_WARP k = UVEC_WARP(BFE(data, int(Shift*BITS_PER_PASS), BITS_PER_PASS));
            UVEC_WARP      key = k;
            UVEC_WARP  histKey = key;
            UVEC_WARP localKey = key + (LT_IDX/WARP_SIZE_RT) * RADICES;

            UVEC_WARP SZ = LOCAL_SORT_SIZE > 0 ? (LOCAL_SORT_SIZE - 1) / BLOCK_SIZE_RT + 1 : 0;
            for (int i=0;i<SZ;i++) {
                uint tid = localIdx + BLOCK_SIZE_RT*i;
                if (tid < LOCAL_SORT_SIZE) localSort[tid] = 0;
            }
            memoryBarrier(); barrier();

            if (validAddress) atomicAdd(localSort[localKey], uint(validAddress));
            UVEC_WARP offset = localHistogramToCarry[k] + localIdx;

            memoryBarrier(); barrier();
            UVEC_WARP sum = 0;
            if (localIdx < RADICES) {
                for (int i=0;i<LOCAL_SORT_SIZE/RADICES;i++) sum += localSort[i * RADICES + localIdx];
                if (localIdx < RADICES) localHistogramToCarry[localIdx] += localHistogram[localIdx] = sum;
            }

            prefix_scan();

            UVEC_WARP outKey = offset - localHistogram[histKey];
            if (validAddress)   KeyOut[outKey] = KEYTYPE(data);
            if (validAddress) ValueOut[outKey] = dataValue;
            memoryBarrier(); barrier();

            addr += BLOCK_SIZE_RT;
        }
    }
}
